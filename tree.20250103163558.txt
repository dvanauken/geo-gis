+-- .gitignore
+-- README.md
+-- package-lock.json
+-- package.json
+-- src
|   -- geometry
|      +-- base
|      |   +-- Coordinate2d.ts: import { CoordinateType } from "./CoordinateType"; import { ICoordinate } from "./ICoordinate";    /**    * Base implementation of 2D coordinates    */   export class Coordinate2D implements ICoordinate {     readonly x: number;     readonly y: number;     readonly coordinateType: CoordinateType = CoordinateType.XY;        constructor(x: number, y: number) {       this.validateCoordinate(x, y);       this.x = x;       this.y = y;     }        protected validateCoordinate(x: number, y: number): void {       if (!Number.isFinite(x) || !Number.isFinite(y)) {         throw new Error('Coordinates must be finite numbers');       }     }        equals(other: ICoordinate): boolean {       const EPSILON = 1e-10;       return Math.abs(this.x - other.x) < EPSILON &&              Math.abs(this.y - other.y) < EPSILON;     }        clone(): ICoordinate {       return new Coordinate2D(this.x, this.y);     }        toString(): string {       return `(${this.x}, ${this.y})`;     }   }
|      |   +-- Coordinate3d.ts: import { Coordinate2D } from "./Coordinate2d"; import { CoordinateType } from "./CoordinateType"; import { ICoordinate } from "./ICoordinate";    /**    * Implementation of 3D coordinates    */   export class Coordinate3D extends Coordinate2D implements ICoordinate {     readonly z: number;     readonly coordinateType: CoordinateType = CoordinateType.XYZ;        constructor(x: number, y: number, z: number) {       super(x, y);       this.validateZ(z);       this.z = z;     }        protected validateZ(z: number): void {       if (!Number.isFinite(z)) {         throw new Error('Z coordinate must be a finite number');       }     }        override equals(other: ICoordinate): boolean {       const EPSILON = 1e-10;       return super.equals(other) &&              'z' in other &&              Math.abs(this.z - other.z) < EPSILON;     }        override clone(): ICoordinate {       return new Coordinate3D(this.x, this.y, this.z);     }        override toString(): string {       return `(${this.x}, ${this.y}, ${this.z})`;     }   }   
|      |   +-- CoordinateFactory.ts: import { Coordinate2D } from "./Coordinate2d"; import { Coordinate3D } from "./Coordinate3d"; import { CoordinateM } from "./CoordinateM"; import { CoordinateZM } from "./CoordinateZM"; import { ICoordinate } from "./ICoordinate";    /**    * Factory class for creating coordinates    */   export class CoordinateFactory {     /**      * Creates a coordinate of the appropriate type based on input values      */     static create(x: number, y: number, z?: number, m?: number): ICoordinate {       if (z !== undefined && m !== undefined) {         return new CoordinateZM(x, y, z, m);       } else if (z !== undefined) {         return new Coordinate3D(x, y, z);       } else if (m !== undefined) {         return new CoordinateM(x, y, m);       } else {         return new Coordinate2D(x, y);       }     }        /**      * Creates a coordinate from an existing one, optionally adding Z or M values      */     static from(coord: ICoordinate, z?: number, m?: number): ICoordinate {       if (z !== undefined && m !== undefined) {         return new CoordinateZM(coord.x, coord.y, z, m);       } else if (z !== undefined) {         return new Coordinate3D(coord.x, coord.y, z);       } else if (m !== undefined) {         return new CoordinateM(coord.x, coord.y, m);       } else {         return new Coordinate2D(coord.x, coord.y);       }     }   }
|      |   +-- CoordinateM.ts: import { Coordinate2D } from "./Coordinate2d"; import { CoordinateType } from "./CoordinateType"; import { ICoordinate } from "./ICoordinate";    /**    * Implementation of 2D coordinates with measure    */   export class CoordinateM extends Coordinate2D implements ICoordinate {     readonly m: number;     readonly coordinateType: CoordinateType = CoordinateType.XYM;        constructor(x: number, y: number, m: number) {       super(x, y);       this.validateM(m);       this.m = m;     }        protected validateM(m: number): void {       if (!Number.isFinite(m)) {         throw new Error('M value must be a finite number');       }     }        override equals(other: ICoordinate): boolean {       const EPSILON = 1e-10;       return super.equals(other) &&              'm' in other &&              Math.abs(this.m - other.m) < EPSILON;     }        override clone(): ICoordinate {       return new CoordinateM(this.x, this.y, this.m);     }        override toString(): string {       return `(${this.x}, ${this.y}, M=${this.m})`;     }   }   
|      |   +-- CoordinateSystem.ts: enum CoordinateSystem {     CARTESIAN_2D,     CARTESIAN_3D,     GEOGRAPHIC_2D,  // Latitude/Longitude     GEOGRAPHIC_3D   // Latitude/Longitude/Altitude   }   
|      |   +-- CoordinateType.ts: export enum CoordinateType {     XY,    // 2D     XYZ,   // 3D     XYM,   // 2D with measure     XYZM   // 3D with measure   }   
|      |   +-- CoordinateZM.ts: import { Coordinate3D } from "./Coordinate3d"; import { CoordinateType } from "./CoordinateType"; import { ICoordinate } from "./ICoordinate";    /**    * Implementation of 3D coordinates with measure    */   export class CoordinateZM extends Coordinate3D implements ICoordinate {     readonly m: number;     readonly coordinateType: CoordinateType = CoordinateType.XYZM;        constructor(x: number, y: number, z: number, m: number) {       super(x, y, z);       this.validateM(m);       this.m = m;     }        protected validateM(m: number): void {       if (!Number.isFinite(m)) {         throw new Error('M value must be a finite number');       }     }        override equals(other: ICoordinate): boolean {       const EPSILON = 1e-10;       return super.equals(other) &&              'm' in other &&              Math.abs(this.m - other.m) < EPSILON;     }        override clone(): ICoordinate {       return new CoordinateZM(this.x, this.y, this.z, this.m);     }        override toString(): string {       return `(${this.x}, ${this.y}, ${this.z}, M=${this.m})`;     }   }   
|      |   +-- Coordinates.ts: /**  * Enumeration of coordinate types  */    /**    * Interface for coordinate values    */                // Export the coordinate system type from the original Point class   export { CoordinateSystem } from '../base/Point';
|      |   +-- ExtendedPoint.ts: import { Coordinate2D } from "./Coordinate2d"; import { Coordinate3D } from "./Coordinate3d"; import { CoordinateFactory } from "./CoordinateFactory"; import { CoordinateM } from "./CoordinateM"; import { CoordinateType } from "./CoordinateType"; import { CoordinateZM } from "./CoordinateZM"; import { ICoordinate } from "./ICoordinate";    /**    * Extended Point class supporting Z and M values    */   export class ExtendedPoint {     private readonly coordinate: ICoordinate;        constructor(coord: ICoordinate) {       this.coordinate = coord;     }        getX(): number {       return this.coordinate.x;     }        getY(): number {       return this.coordinate.y;     }        getZ(): number | undefined {       return 'z' in this.coordinate ? this.coordinate.z : undefined;     }        getM(): number | undefined {       return 'm' in this.coordinate ? this.coordinate.m : undefined;     }        hasZ(): boolean {       return this.coordinate.coordinateType === CoordinateType.XYZ ||              this.coordinate.coordinateType === CoordinateType.XYZM;     }        hasM(): boolean {       return this.coordinate.coordinateType === CoordinateType.XYM ||              this.coordinate.coordinateType === CoordinateType.XYZM;     }        getCoordinateType(): CoordinateType {       return this.coordinate.coordinateType;     }        equals(other: ExtendedPoint): boolean {       return this.coordinate.equals(other.coordinate);     }        clone(): ExtendedPoint {       return new ExtendedPoint(this.coordinate.clone());     }        /**      * Converts to a new point with different coordinate type      */     convert(type: CoordinateType): ExtendedPoint {       switch (type) {         case CoordinateType.XY:           return new ExtendedPoint(new Coordinate2D(this.getX(), this.getY()));                  case CoordinateType.XYZ:           if (!this.hasZ()) {             throw new Error('Cannot convert to XYZ: No Z value present');           }           return new ExtendedPoint(             new Coordinate3D(this.getX(), this.getY(), this.getZ()!)           );                  case CoordinateType.XYM:           if (!this.hasM()) {             throw new Error('Cannot convert to XYM: No M value present');           }           return new ExtendedPoint(             new CoordinateM(this.getX(), this.getY(), this.getM()!)           );                  case CoordinateType.XYZM:           if (!this.hasZ() || !this.hasM()) {             throw new Error('Cannot convert to XYZM: Missing Z or M value');           }           return new ExtendedPoint(             new CoordinateZM(this.getX(), this.getY(), this.getZ()!, this.getM()!)           );       }     }        /**      * Interpolates between two points      * @param other Point to interpolate to      * @param t Interpolation parameter (0 to 1)      */     interpolate(other: ExtendedPoint, t: number): ExtendedPoint {       if (t < 0 || t > 1) {         throw new Error('Interpolation parameter must be between 0 and 1');       }          const x = this.getX() + (other.getX() - this.getX()) * t;       const y = this.getY() + (other.getY() - this.getY()) * t;              const z = this.hasZ() && other.hasZ()         ? this.getZ()! + (other.getZ()! - this.getZ()!) * t         : undefined;              const m = this.hasM() && other.hasM()         ? this.getM()! + (other.getM()! - this.getM()!) * t         : undefined;          return new ExtendedPoint(CoordinateFactory.create(x, y, z, m));     }        toString(): string {       return this.coordinate.toString();     }   }   
|      |   +-- Geometry.ts: interface Geometry extends WKTRepresentable {     isEmpty(): boolean;     is3D(): boolean;     dimension(): number;     getSRID(): number;     setSRID(srid: number): void;     getGeometryType(): string;     equals(other: Geometry): boolean;   }
|      |   +-- ICoordinate.ts: import { CoordinateType } from "./CoordinateType";  export interface ICoordinate {     x: number;     y: number;     z?: number;     m?: number;     coordinateType: CoordinateType;     equals(other: ICoordinate): boolean;     clone(): ICoordinate;     toString(): string;   }   
|      |   +-- Point.ts:      /**    * Implementation of OpenGIS Point geometry    * Represents a location in coordinate space    */   class Point implements Geometry {     private readonly x: number;     private readonly y: number;     private readonly z: number | null;     private srid: number;     private readonly coordinateSystem: CoordinateSystem;        /**      * Creates a new Point      * @param x - X coordinate (or longitude for geographic coordinates)      * @param y - Y coordinate (or latitude for geographic coordinates)      * @param z - Optional Z coordinate (or altitude for geographic coordinates)      * @param srid - Spatial Reference System Identifier (defaults to 0)      * @param coordinateSystem - Coordinate system type (defaults to Cartesian 2D)      */     constructor(       x: number,       y: number,       z: number | null = null,       srid: number = 0,       coordinateSystem: CoordinateSystem = CoordinateSystem.CARTESIAN_2D     ) {       this.validateCoordinates(x, y, z);       this.x = x;       this.y = y;       this.z = z;       this.srid = srid;       this.coordinateSystem = coordinateSystem;     }        /**      * Validates coordinate values based on coordinate system      */     private validateCoordinates(x: number, y: number, z: number | null): void {       if (!Number.isFinite(x) || !Number.isFinite(y)) {         throw new Error('Coordinates must be finite numbers');       }       if (z !== null && !Number.isFinite(z)) {         throw new Error('Z coordinate must be a finite number when provided');       }          if (this.coordinateSystem === CoordinateSystem.GEOGRAPHIC_2D ||            this.coordinateSystem === CoordinateSystem.GEOGRAPHIC_3D) {         // Validate longitude (-180 to 180)         if (x < -180 || x > 180) {           throw new Error('Longitude must be between -180 and 180 degrees');         }         // Validate latitude (-90 to 90)         if (y < -90 || y > 90) {           throw new Error('Latitude must be between -90 and 90 degrees');         }       }     }        // Geometry interface implementation     public isEmpty(): boolean {       return false; // A Point is never empty if it exists     }        public is3D(): boolean {       return this.z !== null;     }        public dimension(): number {       return 0; // Points are 0-dimensional     }        public getSRID(): number {       return this.srid;     }        public setSRID(srid: number): void {       if (srid < 0) {         throw new Error('SRID must be non-negative');       }       this.srid = srid;     }        public getGeometryType(): string {       return 'Point';     }        public equals(other: Geometry): boolean {       if (!(other instanceof Point)) {         return false;       }              const otherPoint = other as Point;       if (this.x !== otherPoint.x || this.y !== otherPoint.y) {         return false;       }              // Compare z values if either point is 3D       if (this.is3D() || otherPoint.is3D()) {         return this.z === otherPoint.z;       }              return true;     }        // WKTRepresentable interface implementation     public asWKT(): string {       if (this.is3D()) {         return `POINT Z (${this.x} ${this.y} ${this.z})`;       }       return `POINT (${this.x} ${this.y})`;     }        // Additional utility methods     /**      * Gets the X coordinate (or longitude for geographic coordinates)      */     public getX(): number {       return this.x;     }        /**      * Gets the Y coordinate (or latitude for geographic coordinates)      */     public getY(): number {       return this.y;     }        /**      * Gets the Z coordinate (or altitude for geographic coordinates)      */     public getZ(): number | null {       return this.z;     }        /**      * Gets the coordinate system type      */     public getCoordinateSystem(): CoordinateSystem {       return this.coordinateSystem;     }        /**      * Calculates the 2D distance to another point using Euclidean distance      * Note: This is only meaningful for Cartesian coordinate systems      */     public distanceTo(other: Point): number {       if (this.coordinateSystem !== other.coordinateSystem) {         throw new Error('Points must be in the same coordinate system');       }              if (this.coordinateSystem === CoordinateSystem.GEOGRAPHIC_2D ||           this.coordinateSystem === CoordinateSystem.GEOGRAPHIC_3D) {         throw new Error('Use greatCircleDistance() for geographic coordinates');       }          const dx = this.x - other.x;       const dy = this.y - other.y;       return Math.sqrt(dx * dx + dy * dy);     }        /**      * Calculates the great circle distance to another point using the Haversine formula      * Only valid for geographic coordinates      * @returns Distance in meters      */     public greatCircleDistance(other: Point): number {       if (this.coordinateSystem !== CoordinateSystem.GEOGRAPHIC_2D &&           this.coordinateSystem !== CoordinateSystem.GEOGRAPHIC_3D) {         throw new Error('Great circle distance only valid for geographic coordinates');       }          const R = 6371000; // Earth's mean radius in meters       const φ1 = this.y * Math.PI / 180;       const φ2 = other.y * Math.PI / 180;       const Δφ = (other.y - this.y) * Math.PI / 180;       const Δλ = (other.x - this.x) * Math.PI / 180;          const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +                 Math.cos(φ1) * Math.cos(φ2) *                 Math.sin(Δλ/2) * Math.sin(Δλ/2);       const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));          return R * c;     }        /**      * Creates a copy of this point      */     public clone(): Point {       return new Point(this.x, this.y, this.z, this.srid, this.coordinateSystem);     }        /**      * Returns a string representation of the point      */     public toString(): string {       return this.asWKT();     }   }      export { Point, CoordinateSystem, Geometry, WKTRepresentable };
|      |   -- WKTRepresentable.ts: interface WKTRepresentable {     asWKT(): string;   }   
|      +-- collection
|      |   +-- GeometryCollection.ts: import { Point, Geometry, WKTRepresentable, CoordinateSystem } from './point'; import { Polyline } from './polyline'; import { Polygon } from './polygon'; import { MultiPolygon } from './multipolygon'; import { MultiPolyline } from './multipolyline';  /**  * Implementation of OpenGIS GeometryCollection  * Represents a collection of arbitrary geometry objects  */ class GeometryCollection implements Geometry {   private readonly geometries: Geometry[];   private srid: number;   private readonly coordinateSystem: CoordinateSystem;    /**    * Creates a new GeometryCollection    * @param geometries - Array of geometry objects    * @param srid - Spatial Reference System Identifier    * @param coordinateSystem - Coordinate system type    * @throws Error if geometries have different coordinate systems    */   constructor(     geometries: Geometry[],     srid: number = 0,     coordinateSystem: CoordinateSystem = CoordinateSystem.CARTESIAN_2D   ) {     this.validateGeometries(geometries);     this.geometries = [...geometries]; // Create defensive copy     this.srid = srid;     this.coordinateSystem = coordinateSystem;   }    /**    * Validates the input geometries array    */   private validateGeometries(geometries: Geometry[]): void {     if (!Array.isArray(geometries)) {       throw new Error('Geometries must be provided as an array');     }      if (geometries.length === 0) {       return; // Empty collection is valid     }      // Helper function to get coordinate system of any geometry     const getGeometryCs = (geom: Geometry): CoordinateSystem => {       if (geom instanceof Point) {         return geom.getCoordinateSystem();       } else if (geom instanceof Polyline || geom instanceof Polygon ||                  geom instanceof MultiPolyline || geom instanceof MultiPolygon) {         return geom.getCoordinateSystem();       } else if (geom instanceof GeometryCollection) {         return geom.getCoordinateSystem();       }       throw new Error('Unknown geometry type');     };      // Check coordinate system consistency     const firstCs = getGeometryCs(geometries[0]);     const invalidCs = geometries.some(geom => getGeometryCs(geom) !== firstCs);     if (invalidCs) {       throw new Error('All geometries must have the same coordinate system');     }      // Check dimensionality consistency     const firstIs3D = geometries[0].is3D();     if (!geometries.every(geom => geom.is3D() === firstIs3D)) {       throw new Error('All geometries must be consistently 2D or 3D');     }   }    // Geometry interface implementation   public isEmpty(): boolean {     return this.geometries.length === 0;   }    public is3D(): boolean {     return this.geometries.length > 0 && this.geometries[0].is3D();   }    public dimension(): number {     if (this.isEmpty()) {       return 0;     }     // Return the highest dimension of contained geometries     return Math.max(...this.geometries.map(geom => geom.dimension()));   }    public getSRID(): number {     return this.srid;   }    public setSRID(srid: number): void {     if (srid < 0) {       throw new Error('SRID must be non-negative');     }     this.srid = srid;     // Update SRID for all contained geometries     this.geometries.forEach(geom => geom.setSRID(srid));   }    public getGeometryType(): string {     return 'GeometryCollection';   }    public equals(other: Geometry): boolean {     if (!(other instanceof GeometryCollection)) {       return false;     }      const otherCollection = other as GeometryCollection;     if (this.geometries.length !== otherCollection.geometries.length) {       return false;     }      // Check if all geometries match (order matters)     return this.geometries.every((geom, index) =>        geom.equals(otherCollection.geometries[index])     );   }    // WKTRepresentable interface implementation   public asWKT(): string {     if (this.isEmpty()) {       return 'GEOMETRYCOLLECTION EMPTY';     }      const geomStrings = this.geometries.map(geom => {       // For nested collections, we need the full WKT       if (geom instanceof GeometryCollection) {         return geom.asWKT();       }       // For other geometries, we keep their full WKT       return geom.asWKT();     }).join(', ');      if (this.is3D()) {       return `GEOMETRYCOLLECTION Z (${geomStrings})`;     }     return `GEOMETRYCOLLECTION (${geomStrings})`;   }    // Additional utility methods   /**    * Gets all geometries in the collection    */   public getGeometries(): Geometry[] {     return [...this.geometries]; // Return defensive copy   }    /**    * Gets the number of geometries in the collection    */   public getNumGeometries(): number {     return this.geometries.length;   }    /**    * Gets the geometry at the specified index    */   public getGeometryN(n: number): Geometry {     if (n < 0 || n >= this.geometries.length) {       throw new Error('Index out of bounds');     }     // Clone the geometry - each geometry type implements its own clone method     if (this.geometries[n] instanceof Point) {       return (this.geometries[n] as Point).clone();     } else if (this.geometries[n] instanceof Polyline) {       return (this.geometries[n] as Polyline).clone();     } else if (this.geometries[n] instanceof Polygon) {       return (this.geometries[n] as Polygon).clone();     } else if (this.geometries[n] instanceof MultiPolyline) {       return (this.geometries[n] as MultiPolyline).clone();     } else if (this.geometries[n] instanceof MultiPolygon) {       return (this.geometries[n] as MultiPolygon).clone();     } else if (this.geometries[n] instanceof GeometryCollection) {       return (this.geometries[n] as GeometryCollection).clone();     }     throw new Error('Unknown geometry type');   }    /**    * Gets the coordinate system type    */   public getCoordinateSystem(): CoordinateSystem {     return this.coordinateSystem;   }    /**    * Gets all geometries of a specific type    * @param type - The geometry type to filter by    */   public getGeometriesByType<T extends Geometry>(type: new (...args: any[]) => T): T[] {     return this.geometries       .filter(geom => geom instanceof type)       .map(geom => (geom as T).clone() as T);   }    /**    * Flattens nested geometry collections into a single collection    * @returns A new GeometryCollection with no nested collections    */   public flatten(): GeometryCollection {     const flattenedGeometries: Geometry[] = [];          const flatten = (geom: Geometry) => {       if (geom instanceof GeometryCollection) {         geom.getGeometries().forEach(g => flatten(g));       } else {         flattenedGeometries.push(geom.clone());       }     };      this.geometries.forEach(geom => flatten(geom));          return new GeometryCollection(       flattenedGeometries,       this.srid,       this.coordinateSystem     );   }    /**    * Creates a copy of this GeometryCollection    */   public clone(): GeometryCollection {     return new GeometryCollection(       this.geometries.map(geom => {         if (geom instanceof Point) {           return geom.clone();         } else if (geom instanceof Polyline) {           return geom.clone();         } else if (geom instanceof Polygon) {           return geom.clone();         } else if (geom instanceof MultiPolyline) {           return geom.clone();         } else if (geom instanceof MultiPolygon) {           return geom.clone();         } else if (geom instanceof GeometryCollection) {           return geom.clone();         }         throw new Error('Unknown geometry type');       }),       this.srid,       this.coordinateSystem     );   }    /**    * Returns a string representation of the geometry collection    */   public toString(): string {     return this.asWKT();   }    /**    * Gets all points from all geometries in the collection    */   public getAllPoints(): Point[] {     const points: Point[] = [];          const collectPoints = (geom: Geometry) => {       if (geom instanceof Point) {         points.push(geom.clone());       } else if (geom instanceof Polyline) {         points.push(...geom.getPoints());       } else if (geom instanceof Polygon) {         points.push(...geom.getExteriorRing().getPoints());         geom.getInteriorRings().forEach(ring =>            points.push(...ring.getPoints())         );       } else if (geom instanceof MultiPolyline) {         points.push(...geom.getAllPoints());       } else if (geom instanceof MultiPolygon) {         geom.getPolygons().forEach(poly => {           points.push(...poly.getExteriorRing().getPoints());           poly.getInteriorRings().forEach(ring =>              points.push(...ring.getPoints())           );         });       } else if (geom instanceof GeometryCollection) {         geom.getGeometries().forEach(g => collectPoints(g));       }     };      this.geometries.forEach(geom => collectPoints(geom));     return points;   } }  export { GeometryCollection };
|      |   +-- LinearRing.ts: import { Point, CoordinateSystem } from './point'; import { Polyline } from './polyline'; import { Geometry, WKTRepresentable } from './point';  /**  * Implementation of OpenGIS MultiLineString (MultiPolyline) geometry  * Represents a collection of Polylines  */ class MultiPolyline implements Geometry {   private readonly polylines: Polyline[];   private srid: number;   private readonly coordinateSystem: CoordinateSystem;    /**    * Creates a new MultiPolyline    * @param polylines - Array of Polylines    * @param srid - Spatial Reference System Identifier (defaults to 0)    * @param coordinateSystem - Coordinate system type    * @throws Error if polylines have different coordinate systems or dimensionality    */   constructor(     polylines: Polyline[],     srid: number = 0,     coordinateSystem: CoordinateSystem = CoordinateSystem.CARTESIAN_2D   ) {     this.validatePolylines(polylines);     this.polylines = [...polylines]; // Create defensive copy     this.srid = srid;     this.coordinateSystem = coordinateSystem;   }    /**    * Validates the input polylines array    */   private validatePolylines(polylines: Polyline[]): void {     if (!Array.isArray(polylines)) {       throw new Error('Polylines must be provided as an array');     }      if (polylines.length === 0) {       return; // Empty MultiPolyline is valid     }      // Check that all polylines have the same coordinate system     const firstCs = polylines[0].getPoints()[0].getCoordinateSystem();     const invalidCs = polylines.some(line =>        line.getPoints().some(point => point.getCoordinateSystem() !== firstCs)     );     if (invalidCs) {       throw new Error('All polylines must have the same coordinate system');     }      // Check that all polylines are either 2D or 3D consistently     const firstIs3D = polylines[0].is3D();     if (!polylines.every(line => line.is3D() === firstIs3D)) {       throw new Error('All polylines must be consistently 2D or 3D');     }   }    // Geometry interface implementation   public isEmpty(): boolean {     return this.polylines.length === 0;   }    public is3D(): boolean {     return this.polylines.length > 0 && this.polylines[0].is3D();   }    public dimension(): number {     return 1; // MultiLineStrings are 1-dimensional   }    public getSRID(): number {     return this.srid;   }    public setSRID(srid: number): void {     if (srid < 0) {       throw new Error('SRID must be non-negative');     }     this.srid = srid;     // Update SRID for all contained polylines     this.polylines.forEach(line => line.setSRID(srid));   }    public getGeometryType(): string {     return 'MultiLineString';   }    public equals(other: Geometry): boolean {     if (!(other instanceof MultiPolyline)) {       return false;     }      const otherMulti = other as MultiPolyline;     if (this.polylines.length !== otherMulti.polylines.length) {       return false;     }      // Check if all polylines match (order matters)     return this.polylines.every((line, index) =>        line.equals(otherMulti.polylines[index])     );   }    // WKTRepresentable interface implementation   public asWKT(): string {     if (this.isEmpty()) {       return 'MULTILINESTRING EMPTY';     }      const linestrings = this.polylines.map(line => {       const coordinates = line.getPoints().map(p => {         if (p.is3D()) {           return `${p.getX()} ${p.getY()} ${p.getZ()}`;         }         return `${p.getX()} ${p.getY()}`;       }).join(', ');       return `(${coordinates})`;     }).join(', ');      if (this.is3D()) {       return `MULTILINESTRING Z (${linestrings})`;     }     return `MULTILINESTRING (${linestrings})`;   }    // Additional utility methods   /**    * Gets all polylines in the collection    */   public getPolylines(): Polyline[] {     return [...this.polylines]; // Return defensive copy   }    /**    * Gets the number of polylines in the collection    */   public getNumGeometries(): number {     return this.polylines.length;   }    /**    * Gets the polyline at the specified index    */   public getGeometryN(n: number): Polyline {     if (n < 0 || n >= this.polylines.length) {       throw new Error('Index out of bounds');     }     return this.polylines[n].clone();   }    /**    * Gets the total length of all polylines in the collection    * For Cartesian coordinates, uses Euclidean distance    * For Geographic coordinates, uses great circle distance    * @returns Total length (in coordinate system units or meters for geographic)    */   public getTotalLength(): number {     return this.polylines.reduce((total, line) => total + line.getLength(), 0);   }    /**    * Gets the coordinate system type    */   public getCoordinateSystem(): CoordinateSystem {     return this.coordinateSystem;   }    /**    * Determines if any polylines in the collection are closed    */   public hasClosedLines(): boolean {     return this.polylines.some(line => line.isClosed());   }    /**    * Gets all points from all polylines    */   public getAllPoints(): Point[] {     return this.polylines.flatMap(line => line.getPoints());   }    /**    * Creates a copy of this MultiPolyline    */   public clone(): MultiPolyline {     return new MultiPolyline(       this.polylines.map(line => line.clone()),       this.srid,       this.coordinateSystem     );   }    /**    * Returns a string representation of the MultiPolyline    */   public toString(): string {     return this.asWKT();   }    /**    * Merges polylines that share endpoints    * @returns A new MultiPolyline with connected polylines merged    */   public mergeConnected(): MultiPolyline {     if (this.polylines.length < 2) {       return this.clone();     }      const merged: Polyline[] = [];     const remaining = [...this.polylines];      while (remaining.length > 0) {       let current = remaining.pop()!;       let merged_any = true;        while (merged_any) {         merged_any = false;         for (let i = remaining.length - 1; i >= 0; i--) {           const other = remaining[i];           const curr_start = current.getStartPoint();           const curr_end = current.getEndPoint();           const other_start = other.getStartPoint();           const other_end = other.getEndPoint();            if (curr_end.equals(other_start)) {             // Connect end-to-start             const points = [...current.getPoints(), ...other.getPoints().slice(1)];             current = new Polyline(points, this.srid, this.coordinateSystem);             remaining.splice(i, 1);             merged_any = true;           } else if (curr_start.equals(other_end)) {             // Connect start-to-end             const points = [...other.getPoints(), ...current.getPoints().slice(1)];             current = new Polyline(points, this.srid, this.coordinateSystem);             remaining.splice(i, 1);             merged_any = true;           }         }       }       merged.push(current);     }      return new MultiPolyline(merged, this.srid, this.coordinateSystem);   } }  export { MultiPolyline };
|      |   +-- MultiPoint.ts: import { Point, Geometry, CoordinateSystem } from '../base/Point'; import { GeometryCollection } from './GeometryCollection';  /**  * Implementation of MultiPoint geometry  * Represents a collection of points  */ class MultiPoint implements Geometry {   private readonly points: Point[];   private srid: number;   private readonly coordinateSystem: CoordinateSystem;    /**    * Creates a new MultiPoint    * @param points Array of points    * @param srid Spatial Reference System Identifier    * @param coordinateSystem Coordinate system type    */   constructor(     points: Point[],     srid: number = 0,     coordinateSystem: CoordinateSystem = CoordinateSystem.CARTESIAN_2D   ) {     this.validatePoints(points);     this.points = points.map(p => p.clone());     this.srid = srid;     this.coordinateSystem = coordinateSystem;   }    private validatePoints(points: Point[]): void {     // Check coordinate system consistency     if (points.length > 0) {       const firstCs = points[0].getCoordinateSystem();       if (!points.every(p => p.getCoordinateSystem() === firstCs)) {         throw new Error('All points must have the same coordinate system');       }        // Check dimensionality consistency       const firstIs3D = points[0].is3D();       if (!points.every(p => p.is3D() === firstIs3D)) {         throw new Error('All points must be consistently 2D or 3D');       }        // Check measure consistency       const firstHasM = 'getM' in points[0] && points[0].getM() !== undefined;       if (!points.every(p => {         const hasM = 'getM' in p && p.getM() !== undefined;         return hasM === firstHasM;       })) {         throw new Error('All points must consistently have or not have measures');       }     }   }    // Geometry interface implementation   public isEmpty(): boolean {     return this.points.length === 0;   }    public is3D(): boolean {     return this.points.length > 0 && this.points[0].is3D();   }    public hasM(): boolean {     return this.points.length > 0 && 'getM' in this.points[0] &&             this.points[0].getM() !== undefined;   }    public dimension(): number {     return 0; // MultiPoint is 0-dimensional   }    public getSRID(): number {     return this.srid;   }    public setSRID(srid: number): void {     if (srid < 0) {       throw new Error('SRID must be non-negative');     }     this.srid = srid;     this.points.forEach(p => p.setSRID(srid));   }    public getGeometryType(): string {     let type = 'MultiPoint';     if (this.is3D() && this.hasM()) {       type += ' ZM';     } else if (this.is3D()) {       type += ' Z';     } else if (this.hasM()) {       type += ' M';     }     return type;   }    public equals(other: Geometry): boolean {     if (!(other instanceof MultiPoint)) {       return false;     }      if (this.points.length !== other.points.length) {       return false;     }      // Check if all points match (order-independent)     const otherPoints = [...other.points];     return this.points.every(point => {       const index = otherPoints.findIndex(p => p.equals(point));       if (index === -1) return false;       otherPoints.splice(index, 1);       return true;     });   }    // MultiPoint-specific methods   /**    * Gets all points in the collection    */   public getPoints(): Point[] {     return this.points.map(p => p.clone());   }    /**    * Gets the number of points    */   public getNumPoints(): number {     return this.points.length;   }    /**    * Gets a point at a specific index    */   public getPointN(n: number): Point {     if (n < 0 || n >= this.points.length) {       throw new Error('Index out of bounds');     }     return this.points[n].clone();   }    /**    * Gets the coordinate system type    */   public getCoordinateSystem(): CoordinateSystem {     return this.coordinateSystem;   }    /**    * Adds a point to the collection    */   public addPoint(point: Point): MultiPoint {     const newPoints = [...this.points, point];     return new MultiPoint(newPoints, this.srid, this.coordinateSystem);   }    /**    * Removes a point from the collection    */   public removePoint(point: Point): MultiPoint {     const index = this.points.findIndex(p => p.equals(point));     if (index === -1) {       return this;     }     const newPoints = [...this.points];     newPoints.splice(index, 1);     return new MultiPoint(newPoints, this.srid, this.coordinateSystem);   }    /**    * Gets the bounding box of all points    */   public getBoundingBox(): {     minX: number;     minY: number;     maxX: number;     maxY: number;     minZ?: number;     maxZ?: number;   } {     if (this.isEmpty()) {       throw new Error('Cannot compute bounding box of empty MultiPoint');     }      const bbox = {       minX: Infinity,       minY: Infinity,       maxX: -Infinity,       maxY: -Infinity,       minZ: this.is3D() ? Infinity : undefined,       maxZ: this.is3D() ? -Infinity : undefined     };      this.points.forEach(point => {       bbox.minX = Math.min(bbox.minX, point.getX());       bbox.minY = Math.min(bbox.minY, point.getY());       bbox.maxX = Math.max(bbox.maxX, point.getX());       bbox.maxY = Math.max(bbox.maxY, point.getY());        if (this.is3D()) {         const z = point.getZ()!;         bbox.minZ = Math.min(bbox.minZ!, z);         bbox.maxZ = Math.max(bbox.maxZ!, z);       }     });      return bbox;   }    /**    * Gets the centroid of all points    */   public getCentroid(): Point {     if (this.isEmpty()) {       throw new Error('Cannot compute centroid of empty MultiPoint');     }      const n = this.points.length;     let sumX = 0, sumY = 0, sumZ = 0;     let hasZ = this.is3D();     let hasM = this.hasM();     let sumM = 0;      this.points.forEach(point => {       sumX += point.getX();       sumY += point.getY();       if (hasZ) {         sumZ += point.getZ()!;       }       if (hasM) {         sumM += point.getM()!;       }     });      if (hasZ && hasM) {       return new Point(sumX / n, sumY / n, sumZ / n, sumM / n);     } else if (hasZ) {       return new Point(sumX / n, sumY / n, sumZ / n);     } else if (hasM) {       return new Point(sumX / n, sumY / n, undefined, sumM / n);     }     return new Point(sumX / n, sumY / n);   }    /**    * Finds all points within a given radius of a point    */   public getPointsWithinDistance(center: Point, radius: number): Point[] {     return this.points.filter(p => p.distanceTo(center) <= radius)                      .map(p => p.clone());   }    /**    * Converts to Well-Known Text (WKT) format    */   public asWKT(): string {     if (this.isEmpty()) {       return 'MULTIPOINT EMPTY';     }      const pointStrings = this.points.map(point => {       const coords = [point.getX(), point.getY()];       if (this.is3D()) {         coords.push(point.getZ()!);       }       if (this.hasM()) {         coords.push(point.getM()!);       }       return `(${coords.join(' ')})`;     });      return `${this.getGeometryType()}(${pointStrings.join(', ')})`;   }    /**    * Creates a deep copy of this MultiPoint    */   public clone(): MultiPoint {     return new MultiPoint(this.points, this.srid, this.coordinateSystem);   }    /**    * Converts to a GeometryCollection    */   public toGeometryCollection(): GeometryCollection {     return new GeometryCollection(this.points);   }    /**    * Returns string representation    */   public toString(): string {     return this.asWKT();   } }  export { MultiPoint };
|      |   +-- MultiPolygon.ts: import { Point, Geometry, WKTRepresentable, CoordinateSystem } from './point'; import { Polygon } from './polygon';  /**  * Implementation of OpenGIS MultiPolygon geometry  * Represents a collection of Polygons  */ class MultiPolygon implements Geometry {   private readonly polygons: Polygon[];   private srid: number;   private readonly coordinateSystem: CoordinateSystem;    /**    * Creates a new MultiPolygon    * @param polygons - Array of Polygons    * @param srid - Spatial Reference System Identifier    * @param coordinateSystem - Coordinate system type    * @throws Error if polygons overlap or have different coordinate systems    */   constructor(     polygons: Polygon[],     srid: number = 0,     coordinateSystem: CoordinateSystem = CoordinateSystem.CARTESIAN_2D   ) {     this.validatePolygons(polygons);     this.polygons = [...polygons]; // Create defensive copy     this.srid = srid;     this.coordinateSystem = coordinateSystem;   }    /**    * Validates the input polygons array    */   private validatePolygons(polygons: Polygon[]): void {     if (!Array.isArray(polygons)) {       throw new Error('Polygons must be provided as an array');     }      if (polygons.length === 0) {       return; // Empty MultiPolygon is valid     }      // Check coordinate system consistency     const firstCs = polygons[0].getExteriorRing().getPoints()[0].getCoordinateSystem();     const invalidCs = polygons.some(poly =>        poly.getExteriorRing().getPoints()[0].getCoordinateSystem() !== firstCs     );     if (invalidCs) {       throw new Error('All polygons must have the same coordinate system');     }      // Check dimensionality consistency     const firstIs3D = polygons[0].is3D();     if (!polygons.every(poly => poly.is3D() === firstIs3D)) {       throw new Error('All polygons must be consistently 2D or 3D');     }      // Check for polygon overlaps     for (let i = 0; i < polygons.length; i++) {       for (let j = i + 1; j < polygons.length; j++) {         if (this.polygonsOverlap(polygons[i], polygons[j])) {           throw new Error('Polygons in a MultiPolygon cannot overlap');         }       }     }   }    /**    * Checks if two polygons overlap    * This is a simplified check that can be enhanced for production use    */   private polygonsOverlap(poly1: Polygon, poly2: Polygon): boolean {     // Check if any vertex of poly1 is inside poly2 or vice versa     const poly1Points = this.getAllPoints(poly1);     const poly2Points = this.getAllPoints(poly2);      return poly1Points.some(p => poly2.contains(p)) ||            poly2Points.some(p => poly1.contains(p));   }    /**    * Gets all points from a polygon (exterior and interior rings)    */   private getAllPoints(polygon: Polygon): Point[] {     return [       ...polygon.getExteriorRing().getPoints(),       ...polygon.getInteriorRings().flatMap(ring => ring.getPoints())     ];   }    // Geometry interface implementation   public isEmpty(): boolean {     return this.polygons.length === 0;   }    public is3D(): boolean {     return this.polygons.length > 0 && this.polygons[0].is3D();   }    public dimension(): number {     return 2; // MultiPolygons are 2-dimensional   }    public getSRID(): number {     return this.srid;   }    public setSRID(srid: number): void {     if (srid < 0) {       throw new Error('SRID must be non-negative');     }     this.srid = srid;     // Update SRID for all contained polygons     this.polygons.forEach(poly => poly.setSRID(srid));   }    public getGeometryType(): string {     return 'MultiPolygon';   }    public equals(other: Geometry): boolean {     if (!(other instanceof MultiPolygon)) {       return false;     }      const otherMulti = other as MultiPolygon;     if (this.polygons.length !== otherMulti.polygons.length) {       return false;     }      // Check if all polygons match (order matters)     return this.polygons.every((poly, index) =>        poly.equals(otherMulti.polygons[index])     );   }    // WKTRepresentable interface implementation   public asWKT(): string {     if (this.isEmpty()) {       return 'MULTIPOLYGON EMPTY';     }      const polygonStrings = this.polygons.map(poly => {       // Remove the 'POLYGON' or 'POLYGON Z' prefix and trim       const wkt = poly.asWKT();       const startIndex = wkt.indexOf('(');       return wkt.substring(startIndex);     }).join(', ');      if (this.is3D()) {       return `MULTIPOLYGON Z (${polygonStrings})`;     }     return `MULTIPOLYGON (${polygonStrings})`;   }    // Additional utility methods   /**    * Gets all polygons in the collection    */   public getPolygons(): Polygon[] {     return [...this.polygons]; // Return defensive copy   }    /**    * Gets the number of polygons in the collection    */   public getNumGeometries(): number {     return this.polygons.length;   }    /**    * Gets the polygon at the specified index    */   public getGeometryN(n: number): Polygon {     if (n < 0 || n >= this.polygons.length) {       throw new Error('Index out of bounds');     }     return this.polygons[n].clone();   }    /**    * Calculates the total area of all polygons    * For geographic coordinates, this is an approximate calculation    * @returns Total area in square units (or square meters for geographic coordinates)    */   public getTotalArea(): number {     return this.polygons.reduce((sum, poly) => sum + poly.getArea(), 0);   }    /**    * Determines if a point lies within any of the polygons    */   public contains(point: Point): boolean {     if (point.getCoordinateSystem() !== this.coordinateSystem) {       throw new Error('Point must be in the same coordinate system as the MultiPolygon');     }     return this.polygons.some(poly => poly.contains(point));   }    /**    * Gets the coordinate system type    */   public getCoordinateSystem(): CoordinateSystem {     return this.coordinateSystem;   }    /**    * Finds adjacent polygons that share boundaries    * @returns Array of polygon index pairs that are adjacent    */   public findAdjacentPolygons(): [number, number][] {     const adjacent: [number, number][] = [];          for (let i = 0; i < this.polygons.length; i++) {       for (let j = i + 1; j < this.polygons.length; j++) {         if (this.polygonsAreAdjacent(this.polygons[i], this.polygons[j])) {           adjacent.push([i, j]);         }       }     }          return adjacent;   }    private polygonsAreAdjacent(poly1: Polygon, poly2: Polygon): boolean {     // Check if polygons share any vertices     const poly1Points = this.getAllPoints(poly1);     const poly2Points = this.getAllPoints(poly2);      let sharedPoints = 0;     for (const p1 of poly1Points) {       if (poly2Points.some(p2 => p2.equals(p1))) {         sharedPoints++;         if (sharedPoints >= 2) {           return true; // Polygons share at least 2 vertices         }       }     }          return false;   }    /**    * Creates a copy of this MultiPolygon    */   public clone(): MultiPolygon {     return new MultiPolygon(       this.polygons.map(poly => poly.clone()),       this.srid,       this.coordinateSystem     );   }    /**    * Returns a string representation of the MultiPolygon    */   public toString(): string {     return this.asWKT();   }    /**    * Merges adjacent polygons if possible    * @returns A new MultiPolygon with adjacent polygons merged    */   public mergeAdjacent(): MultiPolygon {     const adjacent = this.findAdjacentPolygons();     if (adjacent.length === 0) {       return this.clone();     }      // Create sets of connected polygon indices     const sets: Set<number>[] = [];     for (const [i, j] of adjacent) {       let foundSet = false;       for (const set of sets) {         if (set.has(i) || set.has(j)) {           set.add(i);           set.add(j);           foundSet = true;           break;         }       }       if (!foundSet) {         sets.push(new Set([i, j]));       }     }      // Merge polygons in each set     const mergedPolygons: Polygon[] = [];     const usedIndices = new Set<number>();      for (const set of sets) {       // Add merged polygon       const polygonsToMerge = Array.from(set).map(i => this.polygons[i]);       // Note: Actual polygon merging would require complex geometric operations       // This is a placeholder for the merging logic       mergedPolygons.push(polygonsToMerge[0].clone());       set.forEach(i => usedIndices.add(i));     }      // Add remaining unmerged polygons     for (let i = 0; i < this.polygons.length; i++) {       if (!usedIndices.has(i)) {         mergedPolygons.push(this.polygons[i].clone());       }     }      return new MultiPolygon(mergedPolygons, this.srid, this.coordinateSystem);   } }  export { MultiPolygon };
|      |   -- MultiPolyline.ts: import { Point } from "../base/Point"; import { Polyline } from "../primitive/Polyline";  /**  * Implementation of OpenGIS MultiLineString (MultiPolyline) geometry  * Represents a collection of Polylines  */ class MultiPolyline implements Geometry {   private readonly polylines: Polyline[];   private srid: number;   private readonly coordinateSystem: CoordinateSystem;    /**    * Creates a new MultiPolyline    * @param polylines - Array of Polylines    * @param srid - Spatial Reference System Identifier (defaults to 0)    * @param coordinateSystem - Coordinate system type    * @throws Error if polylines have different coordinate systems or dimensionality    */   constructor(     polylines: Polyline[],     srid: number = 0,     coordinateSystem: CoordinateSystem = CoordinateSystem.CARTESIAN_2D   ) {     this.validatePolylines(polylines);     this.polylines = [...polylines]; // Create defensive copy     this.srid = srid;     this.coordinateSystem = coordinateSystem;   }    /**    * Validates the input polylines array    */   private validatePolylines(polylines: Polyline[]): void {     if (!Array.isArray(polylines)) {       throw new Error('Polylines must be provided as an array');     }      if (polylines.length === 0) {       return; // Empty MultiPolyline is valid     }      // Check that all polylines have the same coordinate system     const firstCs = polylines[0].getPoints()[0].getCoordinateSystem();     const invalidCs = polylines.some(line =>        line.getPoints().some(point => point.getCoordinateSystem() !== firstCs)     );     if (invalidCs) {       throw new Error('All polylines must have the same coordinate system');     }      // Check that all polylines are either 2D or 3D consistently     const firstIs3D = polylines[0].is3D();     if (!polylines.every(line => line.is3D() === firstIs3D)) {       throw new Error('All polylines must be consistently 2D or 3D');     }   }    // Geometry interface implementation   public isEmpty(): boolean {     return this.polylines.length === 0;   }    public is3D(): boolean {     return this.polylines.length > 0 && this.polylines[0].is3D();   }    public dimension(): number {     return 1; // MultiLineStrings are 1-dimensional   }    public getSRID(): number {     return this.srid;   }    public setSRID(srid: number): void {     if (srid < 0) {       throw new Error('SRID must be non-negative');     }     this.srid = srid;     // Update SRID for all contained polylines     this.polylines.forEach(line => line.setSRID(srid));   }    public getGeometryType(): string {     return 'MultiLineString';   }    public equals(other: Geometry): boolean {     if (!(other instanceof MultiPolyline)) {       return false;     }      const otherMulti = other as MultiPolyline;     if (this.polylines.length !== otherMulti.polylines.length) {       return false;     }      // Check if all polylines match (order matters)     return this.polylines.every((line, index) =>        line.equals(otherMulti.polylines[index])     );   }    // WKTRepresentable interface implementation   public asWKT(): string {     if (this.isEmpty()) {       return 'MULTILINESTRING EMPTY';     }      const linestrings = this.polylines.map(line => {       const coordinates = line.getPoints().map(p => {         if (p.is3D()) {           return `${p.getX()} ${p.getY()} ${p.getZ()}`;         }         return `${p.getX()} ${p.getY()}`;       }).join(', ');       return `(${coordinates})`;     }).join(', ');      if (this.is3D()) {       return `MULTILINESTRING Z (${linestrings})`;     }     return `MULTILINESTRING (${linestrings})`;   }    // Additional utility methods   /**    * Gets all polylines in the collection    */   public getPolylines(): Polyline[] {     return [...this.polylines]; // Return defensive copy   }    /**    * Gets the number of polylines in the collection    */   public getNumGeometries(): number {     return this.polylines.length;   }    /**    * Gets the polyline at the specified index    */   public getGeometryN(n: number): Polyline {     if (n < 0 || n >= this.polylines.length) {       throw new Error('Index out of bounds');     }     return this.polylines[n].clone();   }    /**    * Gets the total length of all polylines in the collection    * For Cartesian coordinates, uses Euclidean distance    * For Geographic coordinates, uses great circle distance    * @returns Total length (in coordinate system units or meters for geographic)    */   public getTotalLength(): number {     return this.polylines.reduce((total, line) => total + line.getLength(), 0);   }    /**    * Gets the coordinate system type    */   public getCoordinateSystem(): CoordinateSystem {     return this.coordinateSystem;   }    /**    * Determines if any polylines in the collection are closed    */   public hasClosedLines(): boolean {     return this.polylines.some(line => line.isClosed());   }    /**    * Gets all points from all polylines    */   public getAllPoints(): Point[] {     return this.polylines.flatMap(line => line.getPoints());   }    /**    * Creates a copy of this MultiPolyline    */   public clone(): MultiPolyline {     return new MultiPolyline(       this.polylines.map(line => line.clone()),       this.srid,       this.coordinateSystem     );   }    /**    * Returns a string representation of the MultiPolyline    */   public toString(): string {     return this.asWKT();   }    /**    * Merges polylines that share endpoints    * @returns A new MultiPolyline with connected polylines merged    */   public mergeConnected(): MultiPolyline {     if (this.polylines.length < 2) {       return this.clone();     }      const merged: Polyline[] = [];     const remaining = [...this.polylines];      while (remaining.length > 0) {       let current = remaining.pop()!;       let merged_any = true;        while (merged_any) {         merged_any = false;         for (let i = remaining.length - 1; i >= 0; i--) {           const other = remaining[i];           const curr_start = current.getStartPoint();           const curr_end = current.getEndPoint();           const other_start = other.getStartPoint();           const other_end = other.getEndPoint();            if (curr_end.equals(other_start)) {             // Connect end-to-start             const points = [...current.getPoints(), ...other.getPoints().slice(1)];             current = new Polyline(points, this.srid, this.coordinateSystem);             remaining.splice(i, 1);             merged_any = true;           } else if (curr_start.equals(other_end)) {             // Connect start-to-end             const points = [...other.getPoints(), ...current.getPoints().slice(1)];             current = new Polyline(points, this.srid, this.coordinateSystem);             remaining.splice(i, 1);             merged_any = true;           }         }       }       merged.push(current);     }      return new MultiPolyline(merged, this.srid, this.coordinateSystem);   } }  export { MultiPolyline };
|      +-- operation
|      |   +-- binary
|      |   |   -- BinaryOperations.ts: import { Point, Geometry, CoordinateSystem } from '../../base/Point'; import { Polyline } from '../../primitives/Polyline'; import { Polygon, LinearRing } from '../../primitives/Polygon'; import { MultiPolygon } from '../../collections/MultiPolygon'; import { MultiPolyline } from '../../collections/MultiPolyline'; import { GeometryCollection } from '../../collections/GeometryCollection';  /**  * Abstract base class for binary geometric operations  */ abstract class BinaryOperation {   protected geometry1: Geometry;   protected geometry2: Geometry;    constructor(geometry1: Geometry, geometry2: Geometry) {     this.validateGeometries(geometry1, geometry2);     this.geometry1 = geometry1;     this.geometry2 = geometry2;   }    protected validateGeometries(geometry1: Geometry, geometry2: Geometry): void {     if (geometry1.getCoordinateSystem() !== geometry2.getCoordinateSystem()) {       throw new Error('Geometries must have the same coordinate system');     }     if (geometry1.is3D() !== geometry2.is3D()) {       throw new Error('Geometries must have the same dimensionality');     }   }    abstract execute(): Geometry; }  /**  * Computes the intersection of two geometries  */ class IntersectionOperation extends BinaryOperation {   execute(): Geometry {     // Handle different geometry type combinations     if (this.geometry1 instanceof Point) {       return this.intersectPoint(this.geometry1);     } else if (this.geometry1 instanceof Polyline) {       return this.intersectPolyline(this.geometry1);     } else if (this.geometry1 instanceof Polygon) {       return this.intersectPolygon(this.geometry1);     } else if (this.geometry1 instanceof GeometryCollection) {       return this.intersectCollection(this.geometry1);     }     throw new Error('Unsupported geometry type combination');   }    private intersectPoint(point: Point): Geometry {     if (this.geometry2 instanceof Point) {       return point.equals(this.geometry2) ? point.clone() : new GeometryCollection([]);     } else if (this.geometry2 instanceof Polyline) {       return this.pointPolylineIntersection(point, this.geometry2);     } else if (this.geometry2 instanceof Polygon) {       return this.geometry2.contains(point) ? point.clone() : new GeometryCollection([]);     }     return new GeometryCollection([]);   }    private intersectPolyline(line: Polyline): Geometry {     if (this.geometry2 instanceof Point) {       return this.pointPolylineIntersection(this.geometry2, line);     } else if (this.geometry2 instanceof Polyline) {       return this.polylinePolylineIntersection(line, this.geometry2 as Polyline);     } else if (this.geometry2 instanceof Polygon) {       return this.polylinePolygonIntersection(line, this.geometry2);     }     return new GeometryCollection([]);   }    private intersectPolygon(polygon: Polygon): Geometry {     if (this.geometry2 instanceof Point) {       return polygon.contains(this.geometry2) ? this.geometry2.clone() : new GeometryCollection([]);     } else if (this.geometry2 instanceof Polyline) {       return this.polylinePolygonIntersection(this.geometry2, polygon);     } else if (this.geometry2 instanceof Polygon) {       return this.polygonPolygonIntersection(polygon, this.geometry2);     }     return new GeometryCollection([]);   }    private intersectCollection(collection: GeometryCollection): Geometry {     const intersections = collection.getGeometries().map(geom =>        new IntersectionOperation(geom, this.geometry2).execute()     );     return new GeometryCollection(intersections);   }    private pointPolylineIntersection(point: Point, line: Polyline): Geometry {     const points = line.getPoints();     for (let i = 0; i < points.length - 1; i++) {       if (this.pointOnLineSegment(point, points[i], points[i + 1])) {         return point.clone();       }     }     return new GeometryCollection([]);   }    private polylinePolylineIntersection(line1: Polyline, line2: Polyline): Geometry {     const intersectionPoints: Point[] = [];     const points1 = line1.getPoints();     const points2 = line2.getPoints();      for (let i = 0; i < points1.length - 1; i++) {       for (let j = 0; j < points2.length - 1; j++) {         const intersection = this.lineSegmentIntersection(           points1[i], points1[i + 1],           points2[j], points2[j + 1]         );         if (intersection) {           intersectionPoints.push(intersection);         }       }     }      return new GeometryCollection(intersectionPoints);   }    private polylinePolygonIntersection(line: Polyline, polygon: Polygon): Geometry {     const intersectionPoints: Point[] = [];     const linePoints = line.getPoints();     const polygonRings = [       polygon.getExteriorRing(),       ...polygon.getInteriorRings()     ];      // Find intersections with polygon boundaries     for (let i = 0; i < linePoints.length - 1; i++) {       for (const ring of polygonRings) {         const ringPoints = ring.getPoints();         for (let j = 0; j < ringPoints.length - 1; j++) {           const intersection = this.lineSegmentIntersection(             linePoints[i], linePoints[i + 1],             ringPoints[j], ringPoints[j + 1]           );           if (intersection) {             intersectionPoints.push(intersection);           }         }       }     }      // Add line segments that are completely inside the polygon     const segments: Polyline[] = [];     for (let i = 0; i < linePoints.length - 1; i++) {       const p1 = linePoints[i];       const p2 = linePoints[i + 1];       if (polygon.contains(p1) && polygon.contains(p2)) {         segments.push(new Polyline([p1.clone(), p2.clone()]));       }     }      if (segments.length > 0) {       return new MultiPolyline(segments);     }     return new GeometryCollection(intersectionPoints);   }    private polygonPolygonIntersection(poly1: Polygon, poly2: Polygon): Geometry {     // This is a simplified implementation that needs to be enhanced for production use     // A full implementation would need:     // - Proper handling of holes     // - Robust geometric intersection algorithm (e.g., Weiler-Atherton)     // - Handling of degenerate cases          const intersectionPoints: Point[] = [];     const rings1 = [poly1.getExteriorRing(), ...poly1.getInteriorRings()];     const rings2 = [poly2.getExteriorRing(), ...poly2.getInteriorRings()];      // Find intersection points of boundaries     for (const ring1 of rings1) {       for (const ring2 of rings2) {         const points1 = ring1.getPoints();         const points2 = ring2.getPoints();          for (let i = 0; i < points1.length - 1; i++) {           for (let j = 0; j < points2.length - 1; j++) {             const intersection = this.lineSegmentIntersection(               points1[i], points1[i + 1],               points2[j], points2[j + 1]             );             if (intersection) {               intersectionPoints.push(intersection);             }           }         }       }     }      // If no intersection points are found, check if one polygon is inside the other     if (intersectionPoints.length === 0) {       if (this.polygonContainsPolygon(poly1, poly2)) {         return poly2.clone();       }       if (this.polygonContainsPolygon(poly2, poly1)) {         return poly1.clone();       }       return new GeometryCollection([]);     }      // For simplicity, return intersection points     // A full implementation would construct the intersection polygon     return new GeometryCollection(intersectionPoints);   }    private pointOnLineSegment(point: Point, start: Point, end: Point): boolean {     const dx = end.getX() - start.getX();     const dy = end.getY() - start.getY();     const length = Math.sqrt(dx * dx + dy * dy);          if (length === 0) {       return point.equals(start);     }      const t = ((point.getX() - start.getX()) * dx +                 (point.getY() - start.getY()) * dy) / (length * length);      if (t < 0 || t > 1) {       return false;     }      const projX = start.getX() + t * dx;     const projY = start.getY() + t * dy;     const epsilon = 1e-10;      return Math.abs(point.getX() - projX) < epsilon &&            Math.abs(point.getY() - projY) < epsilon;   }    private lineSegmentIntersection(     p1: Point, p2: Point,     p3: Point, p4: Point   ): Point | null {     const dx1 = p2.getX() - p1.getX();     const dy1 = p2.getY() - p1.getY();     const dx2 = p4.getX() - p3.getX();     const dy2 = p4.getY() - p3.getY();      const determinant = dx1 * dy2 - dy1 * dx2;     if (Math.abs(determinant) < 1e-10) {       return null; // Lines are parallel     }      const t1 = ((p3.getX() - p1.getX()) * dy2 - (p3.getY() - p1.getY()) * dx2) / determinant;     const t2 = ((p3.getX() - p1.getX()) * dy1 - (p3.getY() - p1.getY()) * dx1) / determinant;      if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {       const x = p1.getX() + t1 * dx1;       const y = p1.getY() + t1 * dy1;       return new Point(x, y);     }      return null;   }    private polygonContainsPolygon(outer: Polygon, inner: Polygon): boolean {     // Check if all vertices of inner polygon are inside outer polygon     return inner.getExteriorRing().getPoints().every(p => outer.contains(p));   } }  /**  * Computes the union of two geometries  */ class UnionOperation extends BinaryOperation {   execute(): Geometry {     // Handle different geometry type combinations     if (this.geometry1 instanceof Point) {       return this.unionPoint(this.geometry1);     } else if (this.geometry1 instanceof Polyline) {       return this.unionPolyline(this.geometry1);     } else if (this.geometry1 instanceof Polygon) {       return this.unionPolygon(this.geometry1);     } else if (this.geometry1 instanceof GeometryCollection) {       return this.unionCollection(this.geometry1);     }     throw new Error('Unsupported geometry type combination');   }    private unionPoint(point: Point): Geometry {     if (this.geometry2 instanceof Point) {       return point.equals(this.geometry2)          ? point.clone()          : new GeometryCollection([point.clone(), this.geometry2.clone()]);     } else if (this.geometry2 instanceof Polyline) {       const points = [point.clone(), ...this.geometry2.getPoints()];       return new GeometryCollection(points);     } else if (this.geometry2 instanceof Polygon) {       return this.geometry2.contains(point)          ? this.geometry2.clone()          : new GeometryCollection([point.clone(), this.geometry2.clone()]);     }     return new GeometryCollection([point.clone(), this.geometry2]);   }    private unionPolyline(line: Polyline): Geometry {     if (this.geometry2 instanceof Point) {       return this.unionPoint(this.geometry2);     } else if (this.geometry2 instanceof Polyline) {       return new MultiPolyline([line.clone(), this.geometry2.clone()]);     } else if (this.geometry2 instanceof Polygon) {       return new GeometryCollection([line.clone(), this.geometry2.clone()]);     }     return new GeometryCollection([line.clone(), this.geometry2]);   }    private unionPolygon(polygon: Polygon): Geometry {     if (this.geometry2 instanceof Point) {       return this.unionPoint(this.geometry2);     } else if (this.geometry2 instanceof Polyline) {       return new GeometryCollection([polygon.clone(), this.geometry2.clone()]);     } else if (this.geometry2 instanceof Polygon) {       // Simplified union - a full implementation would merge overlapping polygons       return new MultiPolygon([polygon.clone(), this.geometry2.clone()]);     }     return new GeometryCollection([polygon.clone(), this.geometry2]);   }    private unionCollection(collection: GeometryCollection): Geometry {     const geometries = [       ...collection.getGeometries(),       ...(this.geometry2 instanceof GeometryCollection          ? this.geometry2.getGeometries()          : [this.geometry2])     ];     return new GeometryCollection(geometries.map(g => g.clone()));   } }  /**  * Computes the difference between two geometries  */ class DifferenceOperation extends BinaryOperation {   execute(): Geometry {     // A proper implementation would compute true geometric difference     // This is a placeholder that returns the first geometry when there's no intersection     const intersection = new IntersectionOperation(       this.geometry1,       this.geometry2     ).execute();      if (intersection instanceof GeometryCollection && intersection.isEmpty()) {       return this.geometry1.clone();     }      // For points     if (this.geometry1 instanceof Point) {       return this.geometry2.contains(this.geometry1)         ? new GeometryCollection([])         : this.geometry1.clone();     }      // For polylines     if (this.geometry1 instanceof Polyline && this.geometry2 instanceof Polygon) {       return this.polylinePolygonDifference(this.geometry1, this.geometry2);     }      // For polygons     if (this.geometry1 instanceof Polygon && this.geometry2 instanceof Polygon) {       return this.polygonPolygonDifference(this.geometry1, this.geometry2);     }      // Default case - return original geometry     // A full implementation would handle all geometry type combinations     return this.geometry1.clone();   }    private polylinePolygonDifference(line: Polyline, polygon: Polygon): Geometry {     const points = line.getPoints();     const segments: Polyline[] = [];     let currentSegment: Point[] = [];      // Process each point     for (let i = 0; i < points.length; i++) {       const point = points[i];       const isInside = polygon.contains(point);        if (!isInside) {         currentSegment.push(point.clone());       } else if (currentSegment.length > 0) {         if (currentSegment.length > 1) {           segments.push(new Polyline(currentSegment));         }         currentSegment = [];       }     }      // Add final segment if exists     if (currentSegment.length > 1) {       segments.push(new Polyline(currentSegment));     }      return segments.length === 1        ? segments[0]        : new MultiPolyline(segments);   }    private polygonPolygonDifference(poly1: Polygon, poly2: Polygon): Geometry {     // This is a simplified implementation     // A full implementation would:     // 1. Find all intersection points     // 2. Create new boundaries     // 3. Handle holes properly     // 4. Deal with complex cases (multiple resultant polygons)      // For now, we'll just handle the simple case where one polygon is completely inside another     if (this.polygonContainsPolygon(poly2, poly1)) {       return new GeometryCollection([]); // poly1 is completely inside poly2     }     if (!this.polygonsIntersect(poly1, poly2)) {       return poly1.clone(); // No intersection     }      // Return original polygon as placeholder     // Real implementation would compute actual difference     return poly1.clone();   }    private polygonContainsPolygon(outer: Polygon, inner: Polygon): boolean {     return inner.getExteriorRing().getPoints()       .every(p => outer.contains(p));   }    private polygonsIntersect(poly1: Polygon, poly2: Polygon): boolean {     // Check if any vertex of poly1 is inside poly2 or vice versa     return poly1.getExteriorRing().getPoints()       .some(p => poly2.contains(p)) ||       poly2.getExteriorRing().getPoints()       .some(p => poly1.contains(p));   } }  /**  * Computes the symmetric difference between two geometries  */ class SymmetricDifferenceOperation extends BinaryOperation {   execute(): Geometry {     // Symmetric difference can be computed as (A - B) ∪ (B - A)     const diff1 = new DifferenceOperation(this.geometry1, this.geometry2).execute();     const diff2 = new DifferenceOperation(this.geometry2, this.geometry1).execute();     return new UnionOperation(diff1, diff2).execute();   } }  /**  * Utility class to provide easy access to all binary operations  */ class BinaryOperations {   /**    * Computes the intersection of two geometries    */   static intersection(geometry1: Geometry, geometry2: Geometry): Geometry {     return new IntersectionOperation(geometry1, geometry2).execute();   }    /**    * Computes the union of two geometries    */   static union(geometry1: Geometry, geometry2: Geometry): Geometry {     return new UnionOperation(geometry1, geometry2).execute();   }    /**    * Computes the difference between two geometries (geometry1 - geometry2)    */   static difference(geometry1: Geometry, geometry2: Geometry): Geometry {     return new DifferenceOperation(geometry1, geometry2).execute();   }    /**    * Computes the symmetric difference between two geometries    */   static symmetricDifference(geometry1: Geometry, geometry2: Geometry): Geometry {     return new SymmetricDifferenceOperation(geometry1, geometry2).execute();   } }  export {   BinaryOperations,   BinaryOperation,   IntersectionOperation,   UnionOperation,   DifferenceOperation,   SymmetricDifferenceOperation };
|      |   +-- predicate
|      |   |   -- GeometricPredicates.ts: import { Point, Geometry, CoordinateSystem } from '../../base/Point'; import { GeometryCollection } from '../../collection/GeometryCollection'; import { Polygon } from '../../primitive/Polygon'; import { Polyline } from '../../primitive/Polyline';  /**  * Abstract base class for geometric predicates  */ abstract class GeometricPredicate {   protected geometry1: Geometry;   protected geometry2: Geometry;   protected readonly EPSILON = 1e-10; // Tolerance for floating-point comparisons    constructor(geometry1: Geometry, geometry2: Geometry) {     this.validateGeometries(geometry1, geometry2);     this.geometry1 = geometry1;     this.geometry2 = geometry2;   }    protected validateGeometries(geometry1: Geometry, geometry2: Geometry): void {     if (geometry1.getCoordinateSystem() !== geometry2.getCoordinateSystem()) {       throw new Error('Geometries must have the same coordinate system');     }     if (geometry1.is3D() !== geometry2.is3D()) {       throw new Error('Geometries must have the same dimensionality');     }   }    abstract evaluate(): boolean; }  /**  * Tests if two geometries intersect  */ class IntersectsPredicate extends GeometricPredicate {   evaluate(): boolean {     if (this.geometry1 instanceof Point) {       return this.pointIntersects(this.geometry1);     } else if (this.geometry1 instanceof Polyline) {       return this.polylineIntersects(this.geometry1);     } else if (this.geometry1 instanceof Polygon) {       return this.polygonIntersects(this.geometry1);     } else if (this.geometry1 instanceof GeometryCollection) {       return this.collectionIntersects(this.geometry1);     }     throw new Error('Unsupported geometry type');   }    private pointIntersects(point: Point): boolean {     if (this.geometry2 instanceof Point) {       return point.equals(this.geometry2);     } else if (this.geometry2 instanceof Polyline) {       return this.pointIntersectsPolyline(point, this.geometry2);     } else if (this.geometry2 instanceof Polygon) {       return this.geometry2.contains(point);     } else if (this.geometry2 instanceof GeometryCollection) {       return this.geometry2.getGeometries().some(g =>          new IntersectsPredicate(point, g).evaluate()       );     }     return false;   }    private polylineIntersects(line: Polyline): boolean {     if (this.geometry2 instanceof Point) {       return this.pointIntersectsPolyline(this.geometry2, line);     } else if (this.geometry2 instanceof Polyline) {       return this.polylineIntersectsPolyline(line, this.geometry2);     } else if (this.geometry2 instanceof Polygon) {       return this.polylineIntersectsPolygon(line, this.geometry2);     } else if (this.geometry2 instanceof GeometryCollection) {       return this.geometry2.getGeometries().some(g =>          new IntersectsPredicate(line, g).evaluate()       );     }     return false;   }    private polygonIntersects(polygon: Polygon): boolean {     if (this.geometry2 instanceof Point) {       return polygon.contains(this.geometry2);     } else if (this.geometry2 instanceof Polyline) {       return this.polylineIntersectsPolygon(this.geometry2, polygon);     } else if (this.geometry2 instanceof Polygon) {       return this.polygonIntersectsPolygon(polygon, this.geometry2);     } else if (this.geometry2 instanceof GeometryCollection) {       return this.geometry2.getGeometries().some(g =>          new IntersectsPredicate(polygon, g).evaluate()       );     }     return false;   }    private collectionIntersects(collection: GeometryCollection): boolean {     return collection.getGeometries().some(g =>        new IntersectsPredicate(g, this.geometry2).evaluate()     );   }    private pointIntersectsPolyline(point: Point, line: Polyline): boolean {     const points = line.getPoints();     for (let i = 0; i < points.length - 1; i++) {       if (this.pointOnLineSegment(point, points[i], points[i + 1])) {         return true;       }     }     return false;   }    private polylineIntersectsPolyline(line1: Polyline, line2: Polyline): boolean {     const points1 = line1.getPoints();     const points2 = line2.getPoints();      for (let i = 0; i < points1.length - 1; i++) {       for (let j = 0; j < points2.length - 1; j++) {         if (this.lineSegmentsIntersect(           points1[i], points1[i + 1],           points2[j], points2[j + 1]         )) {           return true;         }       }     }     return false;   }    private polylineIntersectsPolygon(line: Polyline, polygon: Polygon): boolean {     // Check if any point of the line is inside the polygon     if (line.getPoints().some(p => polygon.contains(p))) {       return true;     }      // Check if line intersects any polygon boundary     const exteriorRing = polygon.getExteriorRing();     if (this.polylineIntersectsPolyline(line, exteriorRing)) {       return true;     }      // Check interior rings     return polygon.getInteriorRings().some(ring =>        this.polylineIntersectsPolyline(line, ring)     );   }    private polygonIntersectsPolygon(poly1: Polygon, poly2: Polygon): boolean {     // Check if any vertex of one polygon is inside the other     if (poly1.getExteriorRing().getPoints().some(p => poly2.contains(p)) ||         poly2.getExteriorRing().getPoints().some(p => poly1.contains(p))) {       return true;     }      // Check if boundaries intersect     return this.polylineIntersectsPolyline(       poly1.getExteriorRing(),       poly2.getExteriorRing()     );   }    private pointOnLineSegment(point: Point, start: Point, end: Point): boolean {     const dx = end.getX() - start.getX();     const dy = end.getY() - start.getY();     const length = Math.sqrt(dx * dx + dy * dy);          if (length < this.EPSILON) {       return point.equals(start);     }      const t = ((point.getX() - start.getX()) * dx +                 (point.getY() - start.getY()) * dy) / (length * length);      if (t < -this.EPSILON || t > 1 + this.EPSILON) {       return false;     }      const projX = start.getX() + t * dx;     const projY = start.getY() + t * dy;      return Math.abs(point.getX() - projX) < this.EPSILON &&            Math.abs(point.getY() - projY) < this.EPSILON;   }    private lineSegmentsIntersect(     p1: Point, p2: Point,     p3: Point, p4: Point   ): boolean {     // Quick rejection test using bounding boxes     const [minX1, maxX1] = this.minMax(p1.getX(), p2.getX());     const [minY1, maxY1] = this.minMax(p1.getY(), p2.getY());     const [minX2, maxX2] = this.minMax(p3.getX(), p4.getX());     const [minY2, maxY2] = this.minMax(p3.getY(), p4.getY());      if (maxX1 < minX2 - this.EPSILON || minX1 > maxX2 + this.EPSILON ||         maxY1 < minY2 - this.EPSILON || minY1 > maxY2 + this.EPSILON) {       return false;     }      // Cross product method     const ccw = (A: Point, B: Point, C: Point): number => {       return (C.getY() - A.getY()) * (B.getX() - A.getX()) -              (B.getY() - A.getY()) * (C.getX() - A.getX());     };      const ccw1 = ccw(p1, p2, p3);     const ccw2 = ccw(p1, p2, p4);     const ccw3 = ccw(p3, p4, p1);     const ccw4 = ccw(p3, p4, p2);      return (ccw1 * ccw2 < -this.EPSILON && ccw3 * ccw4 < -this.EPSILON) ||            Math.abs(ccw1) < this.EPSILON || Math.abs(ccw2) < this.EPSILON ||            Math.abs(ccw3) < this.EPSILON || Math.abs(ccw4) < this.EPSILON;   }    private minMax(a: number, b: number): [number, number] {     return [Math.min(a, b), Math.max(a, b)];   } }  /**  * Tests if one geometry contains another  */ class ContainsPredicate extends GeometricPredicate {   evaluate(): boolean {     // A geometry contains another if their intersection equals the second geometry     return new EqualsPredicate(       this.geometry2,       new IntersectsPredicate(this.geometry1, this.geometry2).evaluate()         ? this.geometry2         : new GeometryCollection([])     ).evaluate();   } }  /**  * Tests if one geometry is within another  */ class WithinPredicate extends GeometricPredicate {   evaluate(): boolean {     // A is within B if B contains A     return new ContainsPredicate(this.geometry2, this.geometry1).evaluate();   } }  /**  * Tests if two geometries are equal  */ class EqualsPredicate extends GeometricPredicate {   evaluate(): boolean {     // First check type equality     if (this.geometry1.getGeometryType() !== this.geometry2.getGeometryType()) {       return false;     }      // Then check specific type equality     if (this.geometry1 instanceof Point) {       return this.pointEquals(this.geometry1, this.geometry2 as Point);     } else if (this.geometry1 instanceof Polyline) {       return this.polylineEquals(this.geometry1, this.geometry2 as Polyline);     } else if (this.geometry1 instanceof Polygon) {       return this.polygonEquals(this.geometry1, this.geometry2 as Polygon);     } else if (this.geometry1 instanceof GeometryCollection) {       return this.collectionEquals(         this.geometry1,         this.geometry2 as GeometryCollection       );     }     return false;   }    private pointEquals(p1: Point, p2: Point): boolean {     return Math.abs(p1.getX() - p2.getX()) < this.EPSILON &&            Math.abs(p1.getY() - p2.getY()) < this.EPSILON &&            ((!p1.is3D() && !p2.is3D()) ||             Math.abs(p1.getZ()! - p2.getZ()!) < this.EPSILON);   }    private polylineEquals(line1: Polyline, line2: Polyline): boolean {     const points1 = line1.getPoints();     const points2 = line2.getPoints();      if (points1.length !== points2.length) {       return false;     }      return points1.every((p, i) => this.pointEquals(p, points2[i]));   }    private polygonEquals(poly1: Polygon, poly2: Polygon): boolean {     // Check exterior rings     if (!this.polylineEquals(       poly1.getExteriorRing(),       poly2.getExteriorRing()     )) {       return false;     }      // Check interior rings     const rings1 = poly1.getInteriorRings();     const rings2 = poly2.getInteriorRings();      if (rings1.length !== rings2.length) {       return false;     }      // Note: This assumes rings are in the same order     // A more robust implementation would check all possible matchings     return rings1.every((ring, i) =>        this.polylineEquals(ring, rings2[i])     );   }    private collectionEquals(     coll1: GeometryCollection,     coll2: GeometryCollection   ): boolean {     const geoms1 = coll1.getGeometries();     const geoms2 = coll2.getGeometries();      if (geoms1.length !== geoms2.length) {       return false;     }      // Note: This assumes geometries are in the same order     // A more robust implementation would check all possible matchings     return geoms1.every((geom, i) =>        new EqualsPredicate(geom, geoms2[i]).evaluate()     );   } }  /**  * Tests if one geometry touches another (they have at least one boundary point in common)  */ class TouchesPredicate extends GeometricPredicate {   evaluate(): boolean {     // Two geometries touch if their interiors do not intersect but their boundaries do     // This is a simplified implementation     if (this.geometry1 instanceof Point || this.geometry2 instanceof Point) {       return this.evaluateWithPoint();     }          return this.boundariesIntersect() && !this.interiorsIntersect();   }    private evaluateWithPoint(): boolean {     const point = this.geometry1 instanceof Point ? this.geometry1 : this.geometry2;     const other = this.geometry1 instanceof Point ? this.geometry2 : this.geometry1;      if (other instanceof Polyline) {       return this.pointOnPolylineBoundary(point, other);     } else if (other instanceof Polygon) {       return this.pointOnPolygonBoundary(point, other);     }     return false;   }    private pointOnPolylineBoundary(point: Point, line: Polyline): boolean {     const points = line.getPoints();     return point.equals(points[0]) || point.equals(points[points.length - 1]) ||            points.some((p, i) =>               i < points.length - 1 && this.pointOnLineSegment(point, p, points[i + 1])            );   }    private pointOnPolygonBoundary(point: Point, polygon: Polygon): boolean {     const exterior = polygon.getExteriorRing();     if (this.pointOnPolylineBoundary(point, exterior)) {       return true;     }     return polygon.getInteriorRings().some(ring =>        this.pointOnPolylineBoundary(point, ring)     );   }    private pointOnLineSegment(point: Point, start: Point, end: Point): boolean {     const dx = end.getX() - start.getX();     const dy = end.getY() - start.getY();     const length = Math.sqrt(dx * dx + dy * dy);          if (length < this.EPSILON) {       return point.equals(start);     }      const t = ((point.getX() - start.getX()) * dx +                 (point.getY() - start.getY()) * dy) / (length * length);      if (t < -this.EPSILON || t > 1 + this.EPSILON) {       return false;     }      const projX = start.getX() + t * dx;     const projY = start.getY() + t * dy;      return Math.abs(point.getX() - projX) < this.EPSILON &&            Math.abs(point.getY() - projY) < this.EPSILON;   }    private boundariesIntersect(): boolean {     // Get boundaries of both geometries     const boundary1 = this.getBoundary(this.geometry1);     const boundary2 = this.getBoundary(this.geometry2);          return new IntersectsPredicate(boundary1, boundary2).evaluate();   }    private interiorsIntersect(): boolean {     // This is a simplified check - a full implementation would need     // to properly compute geometry interiors     if (this.geometry1 instanceof Polygon && this.geometry2 instanceof Polygon) {       return this.polygonInteriorsIntersect(this.geometry1, this.geometry2);     }     return false;   }    private polygonInteriorsIntersect(poly1: Polygon, poly2: Polygon): boolean {     // Check if any interior point of one polygon is inside the other     const interiorPoint1 = this.getInteriorPoint(poly1);     const interiorPoint2 = this.getInteriorPoint(poly2);          return poly2.contains(interiorPoint1) || poly1.contains(interiorPoint2);   }    private getInteriorPoint(polygon: Polygon): Point {     // Simple method to get an interior point - average of vertices     const points = polygon.getExteriorRing().getPoints();     let sumX = 0, sumY = 0;     points.forEach(p => {       sumX += p.getX();       sumY += p.getY();     });     return new Point(sumX / points.length, sumY / points.length);   }    private getBoundary(geometry: Geometry): Geometry {     if (geometry instanceof Point) {       return new GeometryCollection([]); // Points have empty boundaries     } else if (geometry instanceof Polyline) {       return new GeometryCollection([         geometry.getPoints()[0],         geometry.getPoints()[geometry.getPoints().length - 1]       ]);     } else if (geometry instanceof Polygon) {       return new GeometryCollection([         geometry.getExteriorRing(),         ...geometry.getInteriorRings()       ]);     } else if (geometry instanceof GeometryCollection) {       const boundaries = geometry.getGeometries().map(g => this.getBoundary(g));       return new GeometryCollection(boundaries);     }     throw new Error('Unsupported geometry type');   } }  /**  * Tests if one geometry overlaps another  */ class OverlapsPredicate extends GeometricPredicate {   evaluate(): boolean {     // Two geometries overlap if their intersection has the same dimension as the geometries     // and the intersection is not equal to either geometry     if (this.geometry1.dimension() !== this.geometry2.dimension()) {       return false;     }      const intersection = new IntersectsPredicate(this.geometry1, this.geometry2).evaluate();     if (!intersection) {       return false;     }      return !new EqualsPredicate(this.geometry1, this.geometry2).evaluate() &&            !new ContainsPredicate(this.geometry1, this.geometry2).evaluate() &&            !new ContainsPredicate(this.geometry2, this.geometry1).evaluate();   } }  /**  * Utility class to provide easy access to all geometric predicates  */ class GeometricPredicates {   /**    * Tests if two geometries intersect    */   static intersects(geometry1: Geometry, geometry2: Geometry): boolean {     return new IntersectsPredicate(geometry1, geometry2).evaluate();   }    /**    * Tests if one geometry contains another    */   static contains(geometry1: Geometry, geometry2: Geometry): boolean {     return new ContainsPredicate(geometry1, geometry2).evaluate();   }    /**    * Tests if one geometry is within another    */   static within(geometry1: Geometry, geometry2: Geometry): boolean {     return new WithinPredicate(geometry1, geometry2).evaluate();   }    /**    * Tests if two geometries are equal    */   static equals(geometry1: Geometry, geometry2: Geometry): boolean {     return new EqualsPredicate(geometry1, geometry2).evaluate();   }    /**    * Tests if two geometries touch    */   static touches(geometry1: Geometry, geometry2: Geometry): boolean {     return new TouchesPredicate(geometry1, geometry2).evaluate();   }    /**    * Tests if two geometries overlap    */   static overlaps(geometry1: Geometry, geometry2: Geometry): boolean {     return new OverlapsPredicate(geometry1, geometry2).evaluate();   }    /**    * Tests if two geometries are disjoint (do not intersect)    */   static disjoint(geometry1: Geometry, geometry2: Geometry): boolean {     return !GeometricPredicates.intersects(geometry1, geometry2);   }    /**    * Tests if one geometry covers another    * (similar to contains but includes boundary points)    */   static covers(geometry1: Geometry, geometry2: Geometry): boolean {     return GeometricPredicates.contains(geometry1, geometry2) ||            GeometricPredicates.touches(geometry1, geometry2);   }    /**    * Tests if one geometry is covered by another    */   static coveredBy(geometry1: Geometry, geometry2: Geometry): boolean {     return GeometricPredicates.covers(geometry2, geometry1);   } }  export {   GeometricPredicates,   GeometricPredicate,   IntersectsPredicate,   ContainsPredicate,   WithinPredicate,   EqualsPredicate,   TouchesPredicate,   OverlapsPredicate };
|      |   -- unary
|      |      -- UnaryOperations.ts: import { Point, Geometry, CoordinateSystem } from './point'; import { Polyline } from './polyline'; import { Polygon, LinearRing } from './polygon'; import { MultiPolygon } from './multipolygon'; import { MultiPolyline } from './multipolyline'; import { GeometryCollection } from './geometrycollection';  /**  * Abstract base class for unary geometric operations  */ abstract class UnaryOperation {     protected geometry: Geometry;      constructor(geometry: Geometry) {         this.geometry = geometry;     }      abstract execute(): Geometry; }  /**  * Computes the envelope (bounding box) of a geometry  */ class EnvelopeOperation extends UnaryOperation {     execute(): Polygon {         const points = this.getAllPoints();         if (points.length === 0) {             throw new Error('Cannot compute envelope of empty geometry');         }          // Find min/max coordinates         let minX = Infinity;         let minY = Infinity;         let maxX = -Infinity;         let maxY = -Infinity;         let is3D = points[0].is3D();         let minZ = is3D ? Infinity : null;         let maxZ = is3D ? -Infinity : null;          points.forEach(point => {             minX = Math.min(minX, point.getX());             minY = Math.min(minY, point.getY());             maxX = Math.max(maxX, point.getX());             maxY = Math.max(maxY, point.getY());             if (is3D && point.getZ() !== null) {                 minZ = Math.min(minZ!, point.getZ()!);                 maxZ = Math.max(maxZ!, point.getZ()!);             }         });          // Create envelope polygon         const envelopePoints = [             new Point(minX, minY, is3D ? minZ : null),             new Point(maxX, minY, is3D ? minZ : null),             new Point(maxX, maxY, is3D ? maxZ : null),             new Point(minX, maxY, is3D ? maxZ : null),             new Point(minX, minY, is3D ? minZ : null) // Close the ring         ];          const ring = new LinearRing(envelopePoints);         return new Polygon(ring);     }      private getAllPoints(): Point[] {         if (this.geometry instanceof GeometryCollection) {             return this.geometry.getAllPoints();         } else if (this.geometry instanceof Point) {             return [this.geometry];         } else if (this.geometry instanceof Polyline) {             return this.geometry.getPoints();         } else if (this.geometry instanceof Polygon) {             return [                 ...this.geometry.getExteriorRing().getPoints(),                 ...this.geometry.getInteriorRings().flatMap(ring => ring.getPoints())             ];         } else if (this.geometry instanceof MultiPolyline) {             return this.geometry.getAllPoints();         } else if (this.geometry instanceof MultiPolygon) {             return this.geometry.getPolygons().flatMap(poly => [                 ...poly.getExteriorRing().getPoints(),                 ...poly.getInteriorRings().flatMap(ring => ring.getPoints())             ]);         }         throw new Error('Unsupported geometry type');     } }  /**  * Computes the boundary of a geometry  */ class BoundaryOperation extends UnaryOperation {     execute(): Geometry {         if (this.geometry instanceof Point) {             // A point's boundary is empty             return new GeometryCollection([]);         } else if (this.geometry instanceof Polyline) {             return this.getPolylineBoundary();         } else if (this.geometry instanceof Polygon) {             return this.getPolygonBoundary();         } else if (this.geometry instanceof MultiPolyline) {             return this.getMultiPolylineBoundary();         } else if (this.geometry instanceof MultiPolygon) {             return this.getMultiPolygonBoundary();         } else if (this.geometry instanceof GeometryCollection) {             return this.getCollectionBoundary();         }         throw new Error('Unsupported geometry type');     }      private getPolylineBoundary(): Geometry {         const points = this.geometry as Polyline;         if (points.isClosed()) {             // Closed polylines have no boundary             return new GeometryCollection([]);         }         // Return start and end points         return new GeometryCollection([             points.getPointN(0),             points.getPointN(points.getNumPoints() - 1)         ]);     }      private getPolygonBoundary(): Geometry {         const poly = this.geometry as Polygon;         const rings = [             poly.getExteriorRing(),             ...poly.getInteriorRings()         ];         return new MultiPolyline(rings);     }      private getMultiPolylineBoundary(): Geometry {         const multiLine = this.geometry as MultiPolyline;         const boundaries: Point[] = [];          multiLine.getPolylines().forEach(line => {             if (!line.isClosed()) {                 boundaries.push(line.getPointN(0));                 boundaries.push(line.getPointN(line.getNumPoints() - 1));             }         });          return new GeometryCollection(boundaries);     }      private getMultiPolygonBoundary(): Geometry {         const multiPoly = this.geometry as MultiPolygon;         const boundaries = multiPoly.getPolygons().map(poly => {             const rings = [                 poly.getExteriorRing(),                 ...poly.getInteriorRings()             ];             return new MultiPolyline(rings);         });          return new GeometryCollection(boundaries);     }      private getCollectionBoundary(): Geometry {         const collection = this.geometry as GeometryCollection;         const boundaries = collection.getGeometries().map(geom =>             new BoundaryOperation(geom).execute()         );         return new GeometryCollection(boundaries);     } }  /**  * Computes the convex hull of a geometry  */ class ConvexHullOperation extends UnaryOperation {     execute(): Polygon {         const points = this.getAllPoints();         if (points.length <= 3) {             return this.createSimplePolygon(points);         }          // Graham Scan algorithm for convex hull         const hull = this.grahamScan(points);         return new Polygon(new LinearRing(hull));     }      private getAllPoints(): Point[] {         if (this.geometry instanceof GeometryCollection) {             return this.geometry.getAllPoints();         } else if (this.geometry instanceof Point) {             return [this.geometry];         } else if (this.geometry instanceof Polyline) {             return this.geometry.getPoints();         } else if (this.geometry instanceof Polygon) {             return [                 ...this.geometry.getExteriorRing().getPoints(),                 ...this.geometry.getInteriorRings().flatMap(ring => ring.getPoints())             ];         } else if (this.geometry instanceof MultiPolyline) {             return this.geometry.getAllPoints();         } else if (this.geometry instanceof MultiPolygon) {             return this.geometry.getPolygons().flatMap(poly => [                 ...poly.getExteriorRing().getPoints(),                 ...poly.getInteriorRings().flatMap(ring => ring.getPoints())             ]);         }         throw new Error('Unsupported geometry type');     }      private createSimplePolygon(points: Point[]): Polygon {         if (points.length === 0) {             throw new Error('Cannot create convex hull from empty point set');         }         if (points.length === 1) {             // Create a tiny square around the point             const p = points[0];             const epsilon = 1e-10;             const ring = new LinearRing([                 new Point(p.getX() - epsilon, p.getY() - epsilon),                 new Point(p.getX() + epsilon, p.getY() - epsilon),                 new Point(p.getX() + epsilon, p.getY() + epsilon),                 new Point(p.getX() - epsilon, p.getY() + epsilon),                 new Point(p.getX() - epsilon, p.getY() - epsilon)             ]);             return new Polygon(ring);         }         if (points.length === 2) {             // Create a very thin rectangle             const p1 = points[0];             const p2 = points[1];             const epsilon = 1e-10;             const dx = p2.getX() - p1.getX();             const dy = p2.getY() - p1.getY();             const length = Math.sqrt(dx * dx + dy * dy);             const nx = -dy / length * epsilon;             const ny = dx / length * epsilon;              const ring = new LinearRing([                 new Point(p1.getX() + nx, p1.getY() + ny),                 new Point(p2.getX() + nx, p2.getY() + ny),                 new Point(p2.getX() - nx, p2.getY() - ny),                 new Point(p1.getX() - nx, p1.getY() - ny),                 new Point(p1.getX() + nx, p1.getY() + ny)             ]);             return new Polygon(ring);         }         // For 3 points, create a triangle         const ring = new LinearRing([...points, points[0]]);         return new Polygon(ring);     }      private grahamScan(points: Point[]): Point[] {         if (points.length < 3) {             return points;         }          // Find point with lowest y-coordinate (and leftmost if tied)         let bottomPoint = points[0];         for (const point of points) {             if (point.getY() < bottomPoint.getY() ||                 (point.getY() === bottomPoint.getY() && point.getX() < bottomPoint.getX())) {                 bottomPoint = point;             }         }          // Sort points by polar angle with respect to bottom point         const sortedPoints = points             .filter(p => p !== bottomPoint)             .sort((a, b) => {                 const angleA = Math.atan2(a.getY() - bottomPoint.getY(), a.getX() - bottomPoint.getX());                 const angleB = Math.atan2(b.getY() - bottomPoint.getY(), b.getX() - bottomPoint.getX());                 if (angleA < angleB) return -1;                 if (angleA > angleB) return 1;                 // If angles are equal, take the point that's further                 const distA = (a.getX() - bottomPoint.getX()) ** 2 + (a.getY() - bottomPoint.getY()) ** 2;                 const distB = (b.getX() - bottomPoint.getX()) ** 2 + (b.getY() - bottomPoint.getY()) ** 2;                 return distB - distA;             });          // Graham scan         const hull: Point[] = [bottomPoint];         for (const point of sortedPoints) {             while (hull.length >= 2 && !this.isLeftTurn(                 hull[hull.length - 2],                 hull[hull.length - 1],                 point             )) {                 hull.pop();             }             hull.push(point);         }          // Close the hull         hull.push(hull[0]);         return hull;     }      private isLeftTurn(p1: Point, p2: Point, p3: Point): boolean {         const cross = (p2.getX() - p1.getX()) * (p3.getY() - p1.getY()) -             (p2.getY() - p1.getY()) * (p3.getX() - p1.getX());         return cross > 0;     } }  /**  * Creates a buffer around a geometry  */ class BufferOperation extends UnaryOperation {     private readonly distance: number;     private readonly segments: number;      constructor(geometry: Geometry, distance: number, segments: number = 32) {         super(geometry);         this.distance = distance;         this.segments = Math.max(8, segments);     }      execute(): Polygon {         if (this.geometry instanceof Point) {             return this.createPointBuffer();         } else if (this.geometry instanceof Polyline) {             return this.createPolylineBuffer();         } else if (this.geometry instanceof Polygon) {             return this.createPolygonBuffer();         } else if (this.geometry instanceof GeometryCollection ||             this.geometry instanceof MultiPolyline ||             this.geometry instanceof MultiPolygon) {             return this.createCollectionBuffer();         }         throw new Error('Unsupported geometry type');     }      private createPointBuffer(): Polygon {         const point = this.geometry as Point;         const points: Point[] = [];          // Create circle points         for (let i = 0; i <= this.segments; i++) {             const angle = (2 * Math.PI * i) / this.segments;             const x = point.getX() + this.distance * Math.cos(angle);             const y = point.getY() + this.distance * Math.sin(angle);             points.push(new Point(x, y));         }          return new Polygon(new LinearRing(points));     }      private createPolylineBuffer(): Polygon {         // This is a simplified buffer implementation         // A full implementation would need to handle:         // - Line joins (miter, round, bevel)         // - End caps (round, flat, square)         // - Self-intersections         // - Variable buffer distances         const line = this.geometry as Polyline;         const points = line.getPoints();         const bufferPoints: Point[] = [];          // Create parallel offset lines         for (let i = 0; i < points.length - 1; i++) {             const p1 = points[i];             const p2 = points[i + 1];             const dx = p2.getX() - p1.getX();             const dy = p2.getY() - p1.getY();             const length = Math.sqrt(dx * dx + dy * dy);             const nx = -dy / length * this.distance;             const ny = dx / length * this.distance;              if (i === 0) {                 // Add end cap for start point                 for (let j = 0; j <= this.segments / 4; j++) {                     const angle = Math.PI * (1 - j / (this.segments / 4));                     const x = p1.getX() + this.distance * Math.cos(angle + Math.atan2(dy, dx));                     const y = p1.getY() + this.distance * Math.sin(angle + Math.atan2(dy,import { Point, Geometry, CoordinateSystem } from './point';                     import { Polyline } from './polyline';                     import { Polygon, LinearRing } from './polygon';                     import { MultiPolygon } from './multipolygon';                     import { MultiPolyline } from './multipolyline';                     import { GeometryCollection } from './geometrycollection';                      /**                      * Abstract base class for unary geometric operations                      */                     abstract class UnaryOperation {                         protected geometry: Geometry;                          constructor(geometry: Geometry) {                             this.geometry = geometry;                         }                          abstract execute(): Geometry;                     }                      /**                      * Computes the envelope (bounding box) of a geometry                      */                     class EnvelopeOperation extends UnaryOperation {                         execute(): Polygon {                             const points = this.getAllPoints();                             if (points.length === 0) {                                 throw new Error('Cannot compute envelope of empty geometry');                             }                              // Find min/max coordinates                             let minX = Infinity;                             let minY = Infinity;                             let maxX = -Infinity;                             let maxY = -Infinity;                             let is3D = points[0].is3D();                             let minZ = is3D ? Infinity : null;                             let maxZ = is3D ? -Infinity : null;                              points.forEach(point => {                                 minX = Math.min(minX, point.getX());                                 minY = Math.min(minY, point.getY());                                 maxX = Math.max(maxX, point.getX());                                 maxY = Math.max(maxY, point.getY());                                 if (is3D && point.getZ() !== null) {                                     minZ = Math.min(minZ!, point.getZ()!);                                     maxZ = Math.max(maxZ!, point.getZ()!);                                 }                             });                              // Create envelope polygon                             const envelopePoints = [                                 new Point(minX, minY, is3D ? minZ : null),                                 new Point(maxX, minY, is3D ? minZ : null),                                 new Point(maxX, maxY, is3D ? maxZ : null),                                 new Point(minX, maxY, is3D ? maxZ : null),                                 new Point(minX, minY, is3D ? minZ : null) // Close the ring                             ];                              const ring = new LinearRing(envelopePoints);                             return new Polygon(ring);                         }                          private getAllPoints(): Point[] {                             if (this.geometry instanceof GeometryCollection) {                                 return this.geometry.getAllPoints();                             } else if (this.geometry instanceof Point) {                                 return [this.geometry];                             } else if (this.geometry instanceof Polyline) {                                 return this.geometry.getPoints();                             } else if (this.geometry instanceof Polygon) {                                 return [                                     ...this.geometry.getExteriorRing().getPoints(),                                     ...this.geometry.getInteriorRings().flatMap(ring => ring.getPoints())                                 ];                             } else if (this.geometry instanceof MultiPolyline) {                                 return this.geometry.getAllPoints();                             } else if (this.geometry instanceof MultiPolygon) {                                 return this.geometry.getPolygons().flatMap(poly => [                                     ...poly.getExteriorRing().getPoints(),                                     ...poly.getInteriorRings().flatMap(ring => ring.getPoints())                                 ]);                             }                             throw new Error('Unsupported geometry type');                         }                     }                      /**                      * Computes the boundary of a geometry                      */                     class BoundaryOperation extends UnaryOperation {                         execute(): Geometry {                             if (this.geometry instanceof Point) {                                 // A point's boundary is empty                                 return new GeometryCollection([]);                             } else if (this.geometry instanceof Polyline) {                                 return this.getPolylineBoundary();                             } else if (this.geometry instanceof Polygon) {                                 return this.getPolygonBoundary();                             } else if (this.geometry instanceof MultiPolyline) {                                 return this.getMultiPolylineBoundary();                             } else if (this.geometry instanceof MultiPolygon) {                                 return this.getMultiPolygonBoundary();                             } else if (this.geometry instanceof GeometryCollection) {                                 return this.getCollectionBoundary();                             }                             throw new Error('Unsupported geometry type');                         }                          private getPolylineBoundary(): Geometry {                             const points = this.geometry as Polyline;                             if (points.isClosed()) {                                 // Closed polylines have no boundary                                 return new GeometryCollection([]);                             }                             // Return start and end points                             return new GeometryCollection([                                 points.getPointN(0),                                 points.getPointN(points.getNumPoints() - 1)                             ]);                         }                          private getPolygonBoundary(): Geometry {                             const poly = this.geometry as Polygon;                             const rings = [                                 poly.getExteriorRing(),                                 ...poly.getInteriorRings()                             ];                             return new MultiPolyline(rings);                         }                          private getMultiPolylineBoundary(): Geometry {                             const multiLine = this.geometry as MultiPolyline;                             const boundaries: Point[] = [];                              multiLine.getPolylines().forEach(line => {                                 if (!line.isClosed()) {                                     boundaries.push(line.getPointN(0));                                     boundaries.push(line.getPointN(line.getNumPoints() - 1));                                 }                             });                              return new GeometryCollection(boundaries);                         }                          private getMultiPolygonBoundary(): Geometry {                             const multiPoly = this.geometry as MultiPolygon;                             const boundaries = multiPoly.getPolygons().map(poly => {                                 const rings = [                                     poly.getExteriorRing(),                                     ...poly.getInteriorRings()                                 ];                                 return new MultiPolyline(rings);                             });                              return new GeometryCollection(boundaries);                         }                          private getCollectionBoundary(): Geometry {                             const collection = this.geometry as GeometryCollection;                             const boundaries = collection.getGeometries().map(geom =>                                 new BoundaryOperation(geom).execute()                             );                             return new GeometryCollection(boundaries);                         }                     }                      /**                      * Computes the convex hull of a geometry                      */                     class ConvexHullOperation extends UnaryOperation {                         execute(): Polygon {                             const points = this.getAllPoints();                             if (points.length <= 3) {                                 return this.createSimplePolygon(points);                             }                              // Graham Scan algorithm for convex hull                             const hull = this.grahamScan(points);                             return new Polygon(new LinearRing(hull));                         }                          private getAllPoints(): Point[] {                             if (this.geometry instanceof GeometryCollection) {                                 return this.geometry.getAllPoints();                             } else if (this.geometry instanceof Point) {                                 return [this.geometry];                             } else if (this.geometry instanceof Polyline) {                                 return this.geometry.getPoints();                             } else if (this.geometry instanceof Polygon) {                                 return [                                     ...this.geometry.getExteriorRing().getPoints(),                                     ...this.geometry.getInteriorRings().flatMap(ring => ring.getPoints())                                 ];                             } else if (this.geometry instanceof MultiPolyline) {                                 return this.geometry.getAllPoints();                             } else if (this.geometry instanceof MultiPolygon) {                                 return this.geometry.getPolygons().flatMap(poly => [                                     ...poly.getExteriorRing().getPoints(),                                     ...poly.getInteriorRings().flatMap(ring => ring.getPoints())                                 ]);                             }                             throw new Error('Unsupported geometry type');                         }                          private createSimplePolygon(points: Point[]): Polygon {                             if (points.length === 0) {                                 throw new Error('Cannot create convex hull from empty point set');                             }                             if (points.length === 1) {                                 // Create a tiny square around the point                                 const p = points[0];                                 const epsilon = 1e-10;                                 const ring = new LinearRing([                                     new Point(p.getX() - epsilon, p.getY() - epsilon),                                     new Point(p.getX() + epsilon, p.getY() - epsilon),                                     new Point(p.getX() + epsilon, p.getY() + epsilon),                                     new Point(p.getX() - epsilon, p.getY() + epsilon),                                     new Point(p.getX() - epsilon, p.getY() - epsilon)                                 ]);                                 return new Polygon(ring);                             }                             if (points.length === 2) {                                 // Create a very thin rectangle                                 const p1 = points[0];                                 const p2 = points[1];                                 const epsilon = 1e-10;                                 const dx = p2.getX() - p1.getX();                                 const dy = p2.getY() - p1.getY();                                 const length = Math.sqrt(dx * dx + dy * dy);                                 const nx = -dy / length * epsilon;                                 const ny = dx / length * epsilon;                                  const ring = new LinearRing([                                     new Point(p1.getX() + nx, p1.getY() + ny),                                     new Point(p2.getX() + nx, p2.getY() + ny),                                     new Point(p2.getX() - nx, p2.getY() - ny),                                     new Point(p1.getX() - nx, p1.getY() - ny),                                     new Point(p1.getX() + nx, p1.getY() + ny)                                 ]);                                 return new Polygon(ring);                             }                             // For 3 points, create a triangle                             const ring = new LinearRing([...points, points[0]]);                             return new Polygon(ring);                         }                          private grahamScan(points: Point[]): Point[] {                             if (points.length < 3) {                                 return points;                             }                              // Find point with lowest y-coordinate (and leftmost if tied)                             let bottomPoint = points[0];                             for (const point of points) {                                 if (point.getY() < bottomPoint.getY() ||                                     (point.getY() === bottomPoint.getY() && point.getX() < bottomPoint.getX())) {                                     bottomPoint = point;                                 }                             }                              // Sort points by polar angle with respect to bottom point                             const sortedPoints = points                                 .filter(p => p !== bottomPoint)                                 .sort((a, b) => {                                     const angleA = Math.atan2(a.getY() - bottomPoint.getY(), a.getX() - bottomPoint.getX());                                     const angleB = Math.atan2(b.getY() - bottomPoint.getY(), b.getX() - bottomPoint.getX());                                     if (angleA < angleB) return -1;                                     if (angleA > angleB) return 1;                                     // If angles are equal, take the point that's further                                     const distA = (a.getX() - bottomPoint.getX()) ** 2 + (a.getY() - bottomPoint.getY()) ** 2;                                     const distB = (b.getX() - bottomPoint.getX()) ** 2 + (b.getY() - bottomPoint.getY()) ** 2;                                     return distB - distA;                                 });                              // Graham scan                             const hull: Point[] = [bottomPoint];                             for (const point of sortedPoints) {                                 while (hull.length >= 2 && !this.isLeftTurn(                                     hull[hull.length - 2],                                     hull[hull.length - 1],                                     point                                 )) {                                     hull.pop();                                 }                                 hull.push(point);                             }                              // Close the hull                             hull.push(hull[0]);                             return hull;                         }                          private isLeftTurn(p1: Point, p2: Point, p3: Point): boolean {                             const cross = (p2.getX() - p1.getX()) * (p3.getY() - p1.getY()) -                                 (p2.getY() - p1.getY()) * (p3.getX() - p1.getX());                             return cross > 0;                         }                     }                      /**                      * Creates a buffer around a geometry                      */                     class BufferOperation extends UnaryOperation {                         private readonly distance: number;                         private readonly segments: number;                          constructor(geometry: Geometry, distance: number, segments: number = 32) {                             super(geometry);                             this.distance = distance;                             this.segments = Math.max(8, segments);                         }                          execute(): Polygon {                             if (this.geometry instanceof Point) {                                 return this.createPointBuffer();                             } else if (this.geometry instanceof Polyline) {                                 return this.createPolylineBuffer();                             } else if (this.geometry instanceof Polygon) {                                 return this.createPolygonBuffer();                             } else if (this.geometry instanceof GeometryCollection ||                                 this.geometry instanceof MultiPolyline ||                                 this.geometry instanceof MultiPolygon) {                                 return this.createCollectionBuffer();                             }                             throw new Error('Unsupported geometry type');                         }                          private createPointBuffer(): Polygon {                             const point = this.geometry as Point;                             const points: Point[] = [];                              // Create circle points                             for (let i = 0; i <= this.segments; i++) {                                 const angle = (2 * Math.PI * i) / this.segments;                                 const x = point.getX() + this.distance * Math.cos(angle);                                 const y = point.getY() + this.distance * Math.sin(angle);                                 points.push(new Point(x, y));                             }                              return new Polygon(new LinearRing(points));                         }                          private createPolylineBuffer(): Polygon {                             // This is a simplified buffer implementation                             // A full implementation would need to handle:                             // - Line joins (miter, round, bevel)                             // - End caps (round, flat, square)                             // - Self-intersections                             // - Variable buffer distances                             const line = this.geometry as Polyline;                             const points = line.getPoints();                             const bufferPoints: Point[] = [];                              // Create parallel offset lines                             for (let i = 0; i < points.length - 1; i++) {                                 const p1 = points[i];                                 const p2 = points[i + 1];                                 const dx = p2.getX() - p1.getX();                                 const dy = p2.getY() - p1.getY();                                 const length = Math.sqrt(dx * dx + dy * dy);                                 const nx = -dy / length * this.distance;                                 const ny = dx / length * this.distance;                                  if (i === 0) {                                     // Add end cap for start point                                     for (let j = 0; j <= this.segments / 4; j++) {                                         const angle = Math.PI * (1 - j / (this.segments / 4));                                         const x = p1.getX() + this.distance * Math.cos(angle + Math.atan2(dy, dx));                                         const y = p1.getY() + this.distance * Math.sin(angle + Math.atan2(dy, dx));                                         bufferPoints.push(new Point(x, y));                                     }                                 }                                  // Add parallel offset points                                 bufferPoints.push(new Point(p1.getX() + nx, p1.getY() + ny));                                 bufferPoints.push(new Point(p2.getX() + nx, p2.getY() + ny));                                  if (i === points.length - 2) {                                     // Add end cap for end point                                     for (let j = 0; j <= this.segments / 4; j++) {                                         const angle = j * Math.PI / (this.segments / 4);                                         const x = p2.getX() + this.distance * Math.cos(angle + Math.atan2(dy, dx));                                         const y = p2.getY() + this.distance * Math.sin(angle + Math.atan2(dy, dx));                                         bufferPoints.push(new Point(x, y));                                     }                                 }                             }                              // Add parallel offset points for the other side (in reverse)                             for (let i = points.length - 2; i >= 0; i--) {                                 const p1 = points[i + 1];                                 const p2 = points[i];                                 const dx = p2.getX() - p1.getX();                                 const dy = p2.getY() - p1.getY();                                 const length = Math.sqrt(dx * dx + dy * dy);                                 const nx = -dy / length * this.distance;                                 const ny = dx / length * this.distance;                                  bufferPoints.push(new Point(p1.getX() + nx, p1.getY() + ny));                                 bufferPoints.push(new Point(p2.getX() + nx, p2.getY() + ny));                             }                              // Close the buffer polygon                             bufferPoints.push(bufferPoints[0]);                              return new Polygon(new LinearRing(bufferPoints));                         }                          private createPolygonBuffer(): Polygon {                             // This is a simplified buffer implementation                             // A full implementation would need to handle:                             // - Interior rings                             // - Self-intersections                             // - Variable buffer distances                             const poly = this.geometry as Polygon;                             const exteriorRing = poly.getExteriorRing();                             const points = exteriorRing.getPoints();                             const bufferPoints: Point[] = [];                              // Create parallel offset lines with rounded corners                             for (let i = 0; i < points.length - 1; i++) {                                 const p1 = points[i];                                 const p2 = points[i + 1];                                 const dx = p2.getX() - p1.getX();                                 const dy = p2.getY() - p1.getY();                                 const length = Math.sqrt(dx * dx + dy * dy);                                 const nx = -dy / length * this.distance;                                 const ny = dx / length * this.distance;                                  // Add corner rounding if not first point                                 if (i > 0) {                                     const prev = points[i - 1];                                     const dx_prev = p1.getX() - prev.getX();                                     const dy_prev = p1.getY() - prev.getY();                                     const angle_prev = Math.atan2(dy_prev, dx_prev);                                     const angle_curr = Math.atan2(dy, dx);                                      // Add rounded corner points                                     for (let j = 0; j <= this.segments / 4; j++) {                                         const angle = angle_prev + (angle_curr - angle_prev) * j / (this.segments / 4);                                         const x = p1.getX() + this.distance * Math.cos(angle + Math.PI / 2);                                         const y = p1.getY() + this.distance * Math.sin(angle + Math.PI / 2);                                         bufferPoints.push(new Point(x, y));                                     }                                 }                                  bufferPoints.push(new Point(p1.getX() + nx, p1.getY() + ny));                                 bufferPoints.push(new Point(p2.getX() + nx, p2.getY() + ny));                             }                              // Close the buffer polygon                             bufferPoints.push(bufferPoints[0]);                              return new Polygon(new LinearRing(bufferPoints));                         }                          private createCollectionBuffer(): Polygon {                             // For collections, buffer each geometry and union the results                             // This is a simplified implementation that doesn't handle overlaps                             const buffers: Polygon[] = [];                              if (this.geometry instanceof GeometryCollection) {                                 this.geometry.getGeometries().forEach(geom => {                                     const buffer = new BufferOperation(geom, this.distance, this.segments).execute();                                     buffers.push(buffer);                                 });                             } else if (this.geometry instanceof MultiPolyline) {                                 this.geometry.getPolylines().forEach(line => {                                     const buffer = new BufferOperation(line, this.distance, this.segments).execute();                                     buffers.push(buffer);                                 });                             } else if (this.geometry instanceof MultiPolygon) {                                 this.geometry.getPolygons().forEach(poly => {                                     const buffer = new BufferOperation(poly, this.distance, this.segments).execute();                                     buffers.push(buffer);                                 });                             }                              // Merge all buffers into a single polygon                             // Note: This is a simplified merge that doesn't handle overlaps                             const allPoints = buffers.flatMap(buffer =>                                 buffer.getExteriorRing().getPoints()                             );                              return new ConvexHullOperation(new GeometryCollection(allPoints)).execute();                         }                     }                      /**                      * Utility class to provide easy access to all unary operations                      */                     class UnaryOperations {                         /**                          * Computes the envelope (bounding box) of a geometry                          */                         static envelope(geometry: Geometry): Polygon {                             return new EnvelopeOperation(geometry).execute();                         }                          /**                          * Computes the boundary of a geometry                          */                         static boundary(geometry: Geometry): Geometry {                             return new BoundaryOperation(geometry).execute();                         }                          /**                          * Computes the convex hull of a geometry                          */                         static convexHull(geometry: Geometry): Polygon {                             return new ConvexHullOperation(geometry).execute();                         }                          /**                          * Creates a buffer around a geometry                          */                         static buffer(geometry: Geometry, distance: number, segments: number = 32): Polygon {                             return new BufferOperation(geometry, distance, segments).execute();                         }                     }                      export {                         UnaryOperations,                         UnaryOperation,                         EnvelopeOperation,                         BoundaryOperation,                         ConvexHullOperation,                         BufferOperation                     };
|      +-- primitive
|      |   +-- Curve.ts: import { Point, Geometry, CoordinateSystem } from '../base/Point';  /**  * Type representing a point with interpolation parameter  */ interface ParametricPoint {     point: Point;     parameter: number; // Value between 0 and 1 }  /**  * Abstract base class for all curve geometries  * Represents a continuous path in coordinate space  */ abstract class Curve implements Geometry {     protected srid: number;     protected readonly coordinateSystem: CoordinateSystem;      constructor(         srid: number = 0,         coordinateSystem: CoordinateSystem = CoordinateSystem.CARTESIAN_2D     ) {         this.srid = srid;         this.coordinateSystem = coordinateSystem;     }          // Geometry interface implementation     abstract isEmpty(): boolean;     abstract is3D(): boolean;      public dimension(): number {         return 1; // Curves are 1-dimensional     }      public getSRID(): number {         return this.srid;     }      public setSRID(srid: number): void {         if (srid < 0) {             throw new Error('SRID must be non-negative');         }         this.srid = srid;     }      abstract getGeometryType(): string;     abstract equals(other: Geometry): boolean;      // Abstract methods specific to curves     /**      * Gets the starting point of the curve      */     abstract getStartPoint(): Point;      /**      * Gets the ending point of the curve      */     abstract getEndPoint(): Point;      /**      * Gets the length of the curve      */     abstract getLength(): number;      /**      * Gets a point at a specific distance along the curve      * @param distance Distance along the curve      * @returns Point at the specified distance or null if distance is invalid      */     abstract getPointAtDistance(distance: number): Point | null;      /**      * Gets a point at a specific parametric value (0 to 1)      * @param parameter Value between 0 and 1      * @returns Point at the specified parameter or null if parameter is invalid      */     abstract getPointAtParameter(parameter: number): Point | null;      /**      * Gets the parameter value for a point on the curve      * @param point Point to find parameter for      * @returns Parameter value (0 to 1) or null if point is not on curve      */     abstract getParameterAtPoint(point: Point): number | null;      /**      * Tests if the curve is closed (start point equals end point)      */     abstract isClosed(): boolean;      /**      * Gets the points that define the curve      */     abstract getPoints(): Point[];      /**      * Gets the distance along the curve to a given point      * @param point Point to measure to      * @returns Distance along curve or null if point is not on curve      */     getDistanceToPoint(point: Point): number | null {         const param = this.getParameterAtPoint(point);         if (param === null) {             return null;         }         return param * this.getLength();     }      /**      * Gets a subcurve between two parameters      * @param startParam Start parameter (0 to 1)      * @param endParam End parameter (0 to 1)      * @returns New curve representing the subcurve      */     abstract getSubCurve(startParam: number, endParam: number): Curve;      /**      * Gets the tangent vector at a given parameter      * @param parameter Value between 0 and 1      * @returns Direction vector or null if parameter is invalid      */     abstract getTangentAtParameter(parameter: number): Point | null;      /**      * Gets the curvature at a given parameter      * @param parameter Value between 0 and 1      * @returns Curvature value or null if parameter is invalid      */     abstract getCurvatureAtParameter(parameter: number): number | null;      /**      * Gets a series of points along the curve at regular parameter intervals      * @param numPoints Number of points to generate      */     getRegularPoints(numPoints: number): Point[] {         if (numPoints < 2) {             throw new Error('Number of points must be at least 2');         }          const points: Point[] = [];         for (let i = 0; i < numPoints; i++) {             const param = i / (numPoints - 1);             const point = this.getPointAtParameter(param);             if (point) {                 points.push(point);             }         }         return points;     }      /**      * Gets a series of points along the curve at regular distance intervals      * @param spacing Distance between points      */     getEvenlySpacedPoints(spacing: number): Point[] {         if (spacing <= 0) {             throw new Error('Spacing must be positive');         }          const length = this.getLength();         const numPoints = Math.floor(length / spacing) + 1;         const points: Point[] = [];          for (let i = 0; i < numPoints; i++) {             const distance = i * spacing;             const point = this.getPointAtDistance(distance);             if (point) {                 points.push(point);             }         }          // Add end point if not already included         const lastPoint = this.getEndPoint();         if (points.length > 0 && !points[points.length - 1].equals(lastPoint)) {             points.push(lastPoint);         }          return points;     }      /**      * Computes offset curve (parallel curve)      * @param distance Offset distance (positive for left, negative for right)      */     abstract getOffsetCurve(distance: number): Curve;      /**      * Gets closest point on curve to a given point      * @param point Point to find closest point to      * @returns Closest point and its parameter value      */     abstract getClosestPoint(point: Point): ParametricPoint;      /**      * Tests if a point is on the curve      * @param point Point to test      * @param tolerance Distance tolerance      */     isPointOnCurve(point: Point, tolerance: number = 1e-10): boolean {         const closest = this.getClosestPoint(point);         return point.distanceTo(closest.point) <= tolerance;     }      /**      * Gets the normal vector at a given parameter      * Only valid for planar curves      * @param parameter Value between 0 and 1      */     getNormalAtParameter(parameter: number): Point | null {         const tangent = this.getTangentAtParameter(parameter);         if (!tangent) {             return null;         }         // Rotate tangent 90 degrees counterclockwise         return new Point(-tangent.getY(), tangent.getX());     }      /**      * Projects a point onto the curve      * @param point Point to project      * @returns Projected point and its parameter value      */     projectPoint(point: Point): ParametricPoint {         return this.getClosestPoint(point);     }      /**      * Gets the coordinate system type      */     getCoordinateSystem(): CoordinateSystem {         return this.coordinateSystem;     }      /**      * Validates the curve geometry      * @returns Array of validation errors, empty if valid      */     abstract validate(): string[];      /**      * Smooths the curve using a specified algorithm      * @param tolerance Smoothing tolerance      */     abstract smooth(tolerance: number): Curve;      /**      * Splits the curve at specified parameters      * @param parameters Array of parameter values (0 to 1)      * @returns Array of subcurves      */     split(parameters: number[]): Curve[] {         if (parameters.length === 0) {             return [this];         }          // Sort and validate parameters         const sortedParams = [...new Set(parameters)]             .filter(p => p > 0 && p < 1)             .sort((a, b) => a - b);          // Add start and end parameters         const allParams = [0, ...sortedParams, 1];          // Create subcurves         const curves: Curve[] = [];         for (let i = 0; i < allParams.length - 1; i++) {             curves.push(this.getSubCurve(allParams[i], allParams[i + 1]));         }          return curves;     }      /**      * Reverses the direction of the curve      */     abstract reverse(): Curve;      /**      * Creates a deep copy of the curve      */     abstract clone(): Curve;      asWKT(): string {         throw new Error('Method not implemented.');     }  }  export { Curve, ParametricPoint };
|      |   +-- LineString.ts: 
|      |   +-- LinearRing.ts: import { Point } from "../base/Point"; import { Polyline } from "./Polyline";  /**  * Represents a linear ring - a closed linestring with no self-intersections  * Used internally by Polygon to represent boundaries  */ class LinearRing extends Polyline {   constructor(     points: Point[],     srid: number = 0,     coordinateSystem: CoordinateSystem = CoordinateSystem.CARTESIAN_2D   ) {     super(points, srid, coordinateSystem);     this.validateAsRing();   }    private validateAsRing(): void {     if (this.getNumPoints() < 4) {       throw new Error('A LinearRing must have at least 4 points (first and last being the same)');     }      if (!this.isClosed()) {       throw new Error('A LinearRing must be closed (first and last points must be equal)');     }      // Basic self-intersection check     // Note: A more sophisticated algorithm would be needed for production use     const points = this.getPoints();     for (let i = 0; i < points.length - 2; i++) {       for (let j = i + 2; j < points.length - 1; j++) {         if (this.segmentsIntersect(           points[i], points[i + 1],           points[j], points[j + 1]         )) {           throw new Error('A LinearRing cannot have self-intersections');         }       }     }   }    private segmentsIntersect(     p1: Point, p2: Point,     p3: Point, p4: Point   ): boolean {     // Implementation of line segment intersection test     const ccw = (A: Point, B: Point, C: Point): number => {       return (C.getY() - A.getY()) * (B.getX() - A.getX()) -              (B.getY() - A.getY()) * (C.getX() - A.getX());     };      const a = ccw(p1, p2, p3);     const b = ccw(p1, p2, p4);     const c = ccw(p3, p4, p1);     const d = ccw(p3, p4, p2);      if (((a > 0 && b < 0) || (a < 0 && b > 0)) &&         ((c > 0 && d < 0) || (c < 0 && d > 0))) {       return true;     }      return false;   }    public override getGeometryType(): string {     return 'LinearRing';   } }  export { LinearRing };
|      |   +-- Polygon.ts: import { Point } from "../base/Point"; import { LinearRing } from "./LinearRing";  /**  * Implementation of OpenGIS Polygon geometry  * Represents a planar surface defined by exterior and interior boundaries  */ class Polygon implements Geometry {     private readonly exteriorRing: LinearRing;     private readonly interiorRings: LinearRing[];     private srid: number;     private readonly coordinateSystem: CoordinateSystem;        /**      * Creates a new Polygon      * @param exteriorRing - The outer boundary      * @param interiorRings - Optional array of holes      * @param srid - Spatial Reference System Identifier      * @param coordinateSystem - Coordinate system type      */     constructor(       exteriorRing: LinearRing,       interiorRings: LinearRing[] = [],       srid: number = 0,       coordinateSystem: CoordinateSystem = CoordinateSystem.CARTESIAN_2D     ) {       this.validateRings(exteriorRing, interiorRings);       this.exteriorRing = exteriorRing;       this.interiorRings = [...interiorRings];       this.srid = srid;       this.coordinateSystem = coordinateSystem;     }        /**      * Validates the exterior and interior rings      */     private validateRings(exteriorRing: LinearRing, interiorRings: LinearRing[]): void {       // Check coordinate system consistency       const cs = exteriorRing.getPoints()[0].getCoordinateSystem();       const invalidCs = interiorRings.some(ring =>          ring.getPoints().some(point => point.getCoordinateSystem() !== cs)       );       if (invalidCs) {         throw new Error('All rings must have the same coordinate system');       }          // Check dimensionality consistency       const is3D = exteriorRing.is3D();       if (!interiorRings.every(ring => ring.is3D() === is3D)) {         throw new Error('All rings must be consistently 2D or 3D');       }          // Validate that interior rings are inside exterior ring       for (const ring of interiorRings) {         if (!this.ringContainsRing(exteriorRing, ring)) {           throw new Error('All interior rings must be contained within the exterior ring');         }       }          // Check that interior rings don't intersect each other       for (let i = 0; i < interiorRings.length; i++) {         for (let j = i + 1; j < interiorRings.length; j++) {           if (this.ringsIntersect(interiorRings[i], interiorRings[j])) {             throw new Error('Interior rings cannot intersect each other');           }         }       }     }        private ringContainsRing(outer: LinearRing, inner: LinearRing): boolean {       // Simple point-in-polygon test for the first point of inner ring       return this.pointInRing(inner.getPoints()[0], outer);     }        private pointInRing(point: Point, ring: LinearRing): boolean {       // Ray casting algorithm for point-in-polygon test       let inside = false;       const points = ring.getPoints();       for (let i = 0, j = points.length - 1; i < points.length; j = i++) {         const xi = points[i].getX(), yi = points[i].getY();         const xj = points[j].getX(), yj = points[j].getY();                  const intersect = ((yi > point.getY()) !== (yj > point.getY())) &&           (point.getX() < (xj - xi) * (point.getY() - yi) / (yj - yi) + xi);         if (intersect) inside = !inside;       }       return inside;     }        private ringsIntersect(ring1: LinearRing, ring2: LinearRing): boolean {       // Check if any segments intersect       const points1 = ring1.getPoints();       const points2 = ring2.getPoints();              for (let i = 0; i < points1.length - 1; i++) {         for (let j = 0; j < points2.length - 1; j++) {           if (this.segmentsIntersect(             points1[i], points1[i + 1],             points2[j], points2[j + 1]           )) {             return true;           }         }       }       return false;     }        private segmentsIntersect(       p1: Point, p2: Point,       p3: Point, p4: Point     ): boolean {       // Reuse the LinearRing's segment intersection test       const ring = new LinearRing([p1, p2, p2, p1]);       return ring['segmentsIntersect'](p1, p2, p3, p4);     }        // Geometry interface implementation     public isEmpty(): boolean {       return false; // A valid polygon is never empty     }        public is3D(): boolean {       return this.exteriorRing.is3D();     }        public dimension(): number {       return 2; // Polygons are 2-dimensional     }        public getSRID(): number {       return this.srid;     }        public setSRID(srid: number): void {       if (srid < 0) {         throw new Error('SRID must be non-negative');       }       this.srid = srid;       this.exteriorRing.setSRID(srid);       this.interiorRings.forEach(ring => ring.setSRID(srid));     }        public getGeometryType(): string {       return 'Polygon';     }        public equals(other: Geometry): boolean {       if (!(other instanceof Polygon)) {         return false;       }          const otherPoly = other as Polygon;       if (!this.exteriorRing.equals(otherPoly.exteriorRing)) {         return false;       }          if (this.interiorRings.length !== otherPoly.interiorRings.length) {         return false;       }          return this.interiorRings.every((ring, index) =>          ring.equals(otherPoly.interiorRings[index])       );     }        // WKTRepresentable interface implementation     public asWKT(): string {       const formatRing = (ring: LinearRing): string => {         return '(' + ring.getPoints().map(p => {           if (p.is3D()) {             return `${p.getX()} ${p.getY()} ${p.getZ()}`;           }           return `${p.getX()} ${p.getY()}`;         }).join(', ') + ')';       };          const rings = [         formatRing(this.exteriorRing),         ...this.interiorRings.map(ring => formatRing(ring))       ].join(', ');          if (this.is3D()) {         return `POLYGON Z (${rings})`;       }       return `POLYGON (${rings})`;     }        // Additional utility methods     /**      * Gets the exterior ring of the polygon      */     public getExteriorRing(): LinearRing {       return this.exteriorRing.clone() as LinearRing;     }        /**      * Gets all interior rings (holes) of the polygon      */     public getInteriorRings(): LinearRing[] {       return this.interiorRings.map(ring => ring.clone() as LinearRing);     }        /**      * Gets the number of interior rings      */     public getNumInteriorRings(): number {       return this.interiorRings.length;     }        /**      * Gets an interior ring at the specified index      */     public getInteriorRingN(n: number): LinearRing {       if (n < 0 || n >= this.interiorRings.length) {         throw new Error('Index out of bounds');       }       return this.interiorRings[n].clone() as LinearRing;     }        /**      * Calculates the area of the polygon      * For geographic coordinates, this is an approximate calculation      * @returns Area in square units (or square meters for geographic coordinates)      */     public getArea(): number {       const exteriorArea = this.calculateRingArea(this.exteriorRing);       const interiorArea = this.interiorRings.reduce(         (sum, ring) => sum + this.calculateRingArea(ring),         0       );       return Math.abs(exteriorArea) - Math.abs(interiorArea);     }        private calculateRingArea(ring: LinearRing): number {       // Implementation of the shoelace formula (surveyor's formula)       const points = ring.getPoints();       let area = 0;              for (let i = 0, j = points.length - 1; i < points.length; j = i++) {         area += (points[j].getX() + points[i].getX()) *                  (points[j].getY() - points[i].getY());       }              return area / 2;     }        /**      * Determines if a point lies within the polygon      */     public contains(point: Point): boolean {       if (point.getCoordinateSystem() !== this.coordinateSystem) {         throw new Error('Point must be in the same coordinate system as the polygon');       }          // Check if point is inside exterior ring       const inExterior = this.pointInRing(point, this.exteriorRing);       if (!inExterior) {         return false;       }          // Check if point is outside all interior rings (holes)       return this.interiorRings.every(ring => !this.pointInRing(point, ring));     }        /**      * Creates a copy of this polygon      */     public clone(): Polygon {       return new Polygon(         this.exteriorRing.clone() as LinearRing,         this.interiorRings.map(ring => ring.clone() as LinearRing),         this.srid,         this.coordinateSystem       );     }        /**      * Returns a string representation of the polygon      */     public toString(): string {       return this.asWKT();     }   }      export { Polygon };
|      |   +-- Polyline.ts: import { Point, Geometry, WKTRepresentable, CoordinateSystem } from './point';  /**  * Implementation of OpenGIS LineString (Polyline) geometry  * Represents a sequence of points connected by straight line segments  */ class Polyline implements Geometry {   private readonly points: Point[];   private srid: number;   private readonly coordinateSystem: CoordinateSystem;    /**    * Creates a new Polyline    * @param points - Array of points forming the line    * @param srid - Spatial Reference System Identifier (defaults to 0)    * @param coordinateSystem - Coordinate system type    * @throws Error if less than 2 points provided or points have different coordinate systems    */   constructor(     points: Point[],     srid: number = 0,     coordinateSystem: CoordinateSystem = CoordinateSystem.CARTESIAN_2D   ) {     this.validatePoints(points);     this.points = [...points]; // Create defensive copy     this.srid = srid;     this.coordinateSystem = coordinateSystem;   }    /**    * Validates the input points array    */   private validatePoints(points: Point[]): void {     if (!Array.isArray(points)) {       throw new Error('Points must be provided as an array');     }          if (points.length < 2) {       throw new Error('A Polyline must contain at least 2 points');     }      // Check that all points have the same coordinate system     const firstCs = points[0].getCoordinateSystem();     if (!points.every(p => p.getCoordinateSystem() === firstCs)) {       throw new Error('All points must have the same coordinate system');     }      // Check that all points are either 2D or 3D consistently     const firstIs3D = points[0].is3D();     if (!points.every(p => p.is3D() === firstIs3D)) {       throw new Error('All points must be consistently 2D or 3D');     }   }    // Geometry interface implementation   public isEmpty(): boolean {     return this.points.length === 0;   }    public is3D(): boolean {     return this.points.length > 0 && this.points[0].is3D();   }    public dimension(): number {     return 1; // LineStrings are 1-dimensional   }    public getSRID(): number {     return this.srid;   }    public setSRID(srid: number): void {     if (srid < 0) {       throw new Error('SRID must be non-negative');     }     this.srid = srid;   }    public getGeometryType(): string {     return 'LineString';   }    public equals(other: Geometry): boolean {     if (!(other instanceof Polyline)) {       return false;     }      const otherLine = other as Polyline;     if (this.points.length !== otherLine.points.length) {       return false;     }      return this.points.every((point, index) =>        point.equals(otherLine.points[index])     );   }    // WKTRepresentable interface implementation   public asWKT(): string {     if (this.isEmpty()) {       return 'LINESTRING EMPTY';     }      const coordinates = this.points.map(p => {       if (p.is3D()) {         return `${p.getX()} ${p.getY()} ${p.getZ()}`;       }       return `${p.getX()} ${p.getY()}`;     }).join(', ');      if (this.is3D()) {       return `LINESTRING Z (${coordinates})`;     }     return `LINESTRING (${coordinates})`;   }    // Additional utility methods   /**    * Gets all points in the polyline    */   public getPoints(): Point[] {     return [...this.points]; // Return defensive copy   }    /**    * Gets the number of points in the polyline    */   public getNumPoints(): number {     return this.points.length;   }    /**    * Gets the point at the specified index    */   public getPointN(n: number): Point {     if (n < 0 || n >= this.points.length) {       throw new Error('Index out of bounds');     }     return this.points[n].clone();   }    /**    * Gets the start point of the polyline    */   public getStartPoint(): Point {     if (this.isEmpty()) {       throw new Error('Polyline is empty');     }     return this.points[0].clone();   }    /**    * Gets the end point of the polyline    */   public getEndPoint(): Point {     if (this.isEmpty()) {       throw new Error('Polyline is empty');     }     return this.points[this.points.length - 1].clone();   }    /**    * Calculates the length of the polyline    * For Cartesian coordinates, uses Euclidean distance    * For Geographic coordinates, uses great circle distance    * @returns Length (in coordinate system units or meters for geographic)    */   public getLength(): number {     if (this.points.length < 2) {       return 0;     }      let length = 0;     for (let i = 0; i < this.points.length - 1; i++) {       const p1 = this.points[i];       const p2 = this.points[i + 1];        if (this.coordinateSystem === CoordinateSystem.GEOGRAPHIC_2D ||           this.coordinateSystem === CoordinateSystem.GEOGRAPHIC_3D) {         length += p1.greatCircleDistance(p2);       } else {         length += p1.distanceTo(p2);       }     }      return length;   }    /**    * Determines if the polyline is closed    * A polyline is closed if the first and last points are equal    */   public isClosed(): boolean {     if (this.points.length < 2) {       return false;     }     return this.points[0].equals(this.points[this.points.length - 1]);   }    /**    * Creates a copy of this polyline    */   public clone(): Polyline {     return new Polyline(       this.points.map(p => p.clone()),       this.srid,       this.coordinateSystem     );   }    /**    * Returns a string representation of the polyline    */   public toString(): string {     return this.asWKT();   } }  export { Polyline };
|      |   -- Surface.ts: import { Point, Geometry, CoordinateSystem } from '../base/Point'; import { Curve } from './Curve'; import { Polygon } from './Polygon';  /**  * Interface representing a point with surface parameters  */ interface SurfacePoint {   point: Point;   u: number;  // First surface parameter (0 to 1)   v: number;  // Second surface parameter (0 to 1) }  /**  * Abstract base class for all surface geometries  * Represents a continuous 2-dimensional geometry in coordinate space  */ abstract class Surface implements Geometry {   protected srid: number;   protected readonly coordinateSystem: CoordinateSystem;    constructor(     srid: number = 0,     coordinateSystem: CoordinateSystem = CoordinateSystem.CARTESIAN_2D   ) {     this.srid = srid;     this.coordinateSystem = coordinateSystem;   }    // Geometry interface implementation   abstract isEmpty(): boolean;   abstract is3D(): boolean;    public dimension(): number {     return 2; // Surfaces are 2-dimensional   }    public getSRID(): number {     return this.srid;   }    public setSRID(srid: number): void {     if (srid < 0) {       throw new Error('SRID must be non-negative');     }     this.srid = srid;   }    abstract getGeometryType(): string;   abstract equals(other: Geometry): boolean;    // Abstract methods specific to surfaces   /**    * Gets the area of the surface    */   abstract getArea(): number;    /**    * Gets the perimeter (boundary length) of the surface    */   abstract getPerimeter(): number;    /**    * Gets the centroid of the surface    */   abstract getCentroid(): Point;    /**    * Gets a point on the surface given parametric coordinates    * @param u First parameter (0 to 1)    * @param v Second parameter (0 to 1)    */   abstract getPointAtParameters(u: number, v: number): Point | null;    /**    * Gets the parameters for a point on the surface    * @param point Point to find parameters for    * @returns Surface parameters or null if point is not on surface    */   abstract getParametersAtPoint(point: Point): { u: number; v: number; } | null;    /**    * Gets the boundary of the surface    * @returns Array of curves representing the boundary    */   abstract getBoundary(): Curve[];    /**    * Tests if the surface is closed (has no boundary)    */   abstract isClosed(): boolean;    /**    * Gets the normal vector at a point on the surface    * @param point Point to get normal at    */   abstract getNormalAtPoint(point: Point): Point | null;    /**    * Tests if a point lies on the surface    * @param point Point to test    * @param tolerance Distance tolerance    */   abstract isPointOnSurface(point: Point, tolerance?: number): boolean;    /**    * Gets the closest point on the surface to a given point    * @param point Point to find closest point to    */   abstract getClosestPoint(point: Point): SurfacePoint;    /**    * Gets a triangulation of the surface    * @param maxTriangleSize Maximum size of triangles    * @returns Array of triangular polygons    */   abstract triangulate(maxTriangleSize?: number): Polygon[];    /**    * Gets the coordinate system type    */   getCoordinateSystem(): CoordinateSystem {     return this.coordinateSystem;   }    /**    * Projects a point onto the surface    * @param point Point to project    */   projectPoint(point: Point): SurfacePoint {     return this.getClosestPoint(point);   }    /**    * Gets the Gaussian curvature at a point    * @param point Point to get curvature at    */   abstract getGaussianCurvature(point: Point): number | null;    /**    * Gets the mean curvature at a point    * @param point Point to get curvature at    */   abstract getMeanCurvature(point: Point): number | null;    /**    * Gets the principal curvatures at a point    * @param point Point to get curvatures at    * @returns Array [k1, k2] of principal curvatures or null    */   abstract getPrincipalCurvatures(point: Point): [number, number] | null;    /**    * Gets the principal directions at a point    * @param point Point to get directions at    * @returns Array [d1, d2] of principal direction vectors or null    */   abstract getPrincipalDirections(point: Point): [Point, Point] | null;    /**    * Intersects the surface with a curve    * @param curve Curve to intersect with    * @returns Array of intersection points    */   abstract intersectWithCurve(curve: Curve): Point[];    /**    * Intersects the surface with another surface    * @param surface Surface to intersect with    * @returns Array of intersection curves    */   abstract intersectWithSurface(surface: Surface): Curve[];    /**    * Gets a section of the surface by intersecting with a plane    * @param planePoint Point on the plane    * @param planeNormal Normal vector of the plane    * @returns Array of intersection curves    */   abstract getSectionWithPlane(planePoint: Point, planeNormal: Point): Curve[];    /**    * Gets the tangent plane at a point    * @param point Point to get tangent plane at    * @returns Array [point, normal] representing the tangent plane or null    */   abstract getTangentPlane(point: Point): [Point, Point] | null;    /**    * Validates the surface geometry    * @returns Array of validation errors, empty if valid    */   abstract validate(): string[];    /**    * Smooths the surface using a specified algorithm    * @param tolerance Smoothing tolerance    */   abstract smooth(tolerance: number): Surface;    /**    * Gets a subsurface defined by parameter ranges    * @param uMin Minimum u parameter    * @param uMax Maximum u parameter    * @param vMin Minimum v parameter    * @param vMax Maximum v parameter    */   abstract getSubSurface(     uMin: number,     uMax: number,     vMin: number,     vMax: number   ): Surface;    /**    * Computes offset surface    * @param distance Offset distance (positive for outward, negative for inward)    */   abstract getOffsetSurface(distance: number): Surface;    /**    * Gets surface properties at a point    * @param point Point to get properties at    * @returns Object containing various surface properties    */   getSurfaceProperties(point: Point): {     normal: Point | null;     gaussianCurvature: number | null;     meanCurvature: number | null;     principalCurvatures: [number, number] | null;     principalDirections: [Point, Point] | null;   } {     return {       normal: this.getNormalAtPoint(point),       gaussianCurvature: this.getGaussianCurvature(point),       meanCurvature: this.getMeanCurvature(point),       principalCurvatures: this.getPrincipalCurvatures(point),       principalDirections: this.getPrincipalDirections(point)     };   }    /**    * Creates a deep copy of the surface    */   abstract clone(): Surface;    asWKT(): string {     throw new Error('Method not implemented.'); }  }  export { Surface, SurfacePoint };
|      +-- surface
|      |   +-- PolyhedralSurface.ts: import { Point, Geometry, CoordinateSystem } from '../base/Point'; import { Curve } from '../primitive/Curve'; import { LinearRing } from '../primitive/LinearRing'; import { Polygon } from '../primitive/Polygon'; import { Surface } from '../primitive/Surface';  /**  * Represents a face in a polyhedral surface  */ interface Face {   polygon: Polygon;   neighbors: Set<number>; // Indices of neighboring faces }  /**  * Implementation of PolyhedralSurface geometry  * Represents a surface composed of polygonal faces in 3D space  */ class PolyhedralSurface extends Surface {   private readonly faces: Face[];   private readonly patches: Polygon[];  // Original polygons for WKT output    /**    * Creates a new PolyhedralSurface    * @param polygons Array of polygons forming the surface    * @param srid Spatial Reference System Identifier    * @param coordinateSystem Coordinate system type    */   constructor(     polygons: Polygon[],     srid: number = 0,     coordinateSystem: CoordinateSystem = CoordinateSystem.CARTESIAN_3D   ) {     super(srid, coordinateSystem);     this.validatePolygons(polygons);     this.patches = polygons.map(p => p.clone());     this.faces = this.buildTopology(polygons);   }    private validatePolygons(polygons: Polygon[]): void {     if (polygons.length === 0) {       throw new Error('PolyhedralSurface must contain at least one polygon');     }      // Check 3D requirement     if (!polygons.every(poly => poly.is3D())) {       throw new Error('All polygons must be 3D');     }      // Check coordinate system consistency     const firstCs = polygons[0].getCoordinateSystem();     if (!polygons.every(poly => poly.getCoordinateSystem() === firstCs)) {       throw new Error('All polygons must have the same coordinate system');     }      // Check planarity of each polygon     polygons.forEach(this.validatePlanarity);   }    private validatePlanarity(polygon: Polygon): void {     const points = polygon.getExteriorRing().getPoints();     if (points.length < 4) return; // Triangle is always planar      // Use first three non-collinear points to define plane     const p1 = points[0];     let p2 = points[1];     let p3 = points[2];     let i = 3;          while (i < points.length && this.arePointsCollinear(p1, p2, p3)) {       p2 = points[i - 1];       p3 = points[i];       i++;     }      if (i === points.length && this.arePointsCollinear(p1, p2, p3)) {       throw new Error('Cannot determine plane from collinear points');     }      // Get plane normal     const normal = this.computeNormal(p1, p2, p3);      // Check if all points lie on the plane     const EPSILON = 1e-10;     const d = -(normal.getX() * p1.getX() +                  normal.getY() * p1.getY() +                  normal.getZ()! * p1.getZ()!);      for (const point of points) {       const distance = Math.abs(normal.getX() * point.getX() +                               normal.getY() * point.getY() +                               normal.getZ()! * point.getZ()! + d);       if (distance > EPSILON) {         throw new Error('Polygon is not planar');       }     }   }    private arePointsCollinear(p1: Point, p2: Point, p3: Point): boolean {     const EPSILON = 1e-10;     const v1 = new Point(       p2.getX() - p1.getX(),       p2.getY() - p1.getY(),       p2.getZ()! - p1.getZ()!     );     const v2 = new Point(       p3.getX() - p1.getX(),       p3.getY() - p1.getY(),       p3.getZ()! - p1.getZ()!     );          // Check if cross product is zero (vectors are parallel)     const cross = this.crossProduct(v1, v2);     return Math.abs(cross.getX()) < EPSILON &&            Math.abs(cross.getY()) < EPSILON &&            Math.abs(cross.getZ()!) < EPSILON;   }    private crossProduct(v1: Point, v2: Point): Point {     return new Point(       v1.getY() * v2.getZ()! - v1.getZ()! * v2.getY(),       v1.getZ()! * v2.getX() - v1.getX() * v2.getZ()!,       v1.getX() * v2.getY() - v1.getY() * v2.getX()     );   }    private computeNormal(p1: Point, p2: Point, p3: Point): Point {     const v1 = new Point(       p2.getX() - p1.getX(),       p2.getY() - p1.getY(),       p2.getZ()! - p1.getZ()!     );     const v2 = new Point(       p3.getX() - p1.getX(),       p3.getY() - p1.getY(),       p3.getZ()! - p1.getZ()!     );          const cross = this.crossProduct(v1, v2);     const length = Math.sqrt(       cross.getX() * cross.getX() +       cross.getY() * cross.getY() +       cross.getZ()! * cross.getZ()!     );          return new Point(       cross.getX() / length,       cross.getY() / length,       cross.getZ()! / length     );   }    private buildTopology(polygons: Polygon[]): Face[] {     const faces: Face[] = polygons.map(poly => ({       polygon: poly.clone(),       neighbors: new Set<number>()     }));      // Find adjacent faces     for (let i = 0; i < faces.length; i++) {       for (let j = i + 1; j < faces.length; j++) {         if (this.arePolygonsAdjacent(faces[i].polygon, faces[j].polygon)) {           faces[i].neighbors.add(j);           faces[j].neighbors.add(i);         }       }     }      return faces;   }    private arePolygonsAdjacent(poly1: Polygon, poly2: Polygon): boolean {     const edges1 = this.getPolygonEdges(poly1);     const edges2 = this.getPolygonEdges(poly2);      // Check if polygons share any edge     for (const edge1 of edges1) {       for (const edge2 of edges2) {         if (this.areEdgesEqual(edge1, edge2)) {           return true;         }       }     }     return false;   }    private getPolygonEdges(polygon: Polygon): [Point, Point][] {     const points = polygon.getExteriorRing().getPoints();     const edges: [Point, Point][] = [];          for (let i = 0; i < points.length - 1; i++) {       edges.push([points[i], points[i + 1]]);     }          return edges;   }    private areEdgesEqual(     edge1: [Point, Point],     edge2: [Point, Point]   ): boolean {     return (edge1[0].equals(edge2[0]) && edge1[1].equals(edge2[1])) ||            (edge1[0].equals(edge2[1]) && edge1[1].equals(edge2[0]));   }    // Surface interface implementation   public override getArea(): number {     return this.faces.reduce((sum, face) => sum + face.polygon.getArea(), 0);   }    public override getPerimeter(): number {     // Get the length of all boundary edges     const boundaryEdges = this.getBoundaryEdges();     return boundaryEdges.reduce((sum, edge) =>        sum + edge[0].distanceTo(edge[1]), 0     );   }    private getBoundaryEdges(): [Point, Point][] {     const edgeCount = new Map<string, number>();          // Count occurrences of each edge     this.faces.forEach(face => {       const edges = this.getPolygonEdges(face.polygon);       edges.forEach(edge => {         const key = this.getEdgeKey(edge);         edgeCount.set(key, (edgeCount.get(key) || 0) + 1);       });     });      // Collect edges that appear only once (boundary edges)     const boundaryEdges: [Point, Point][] = [];     this.faces.forEach(face => {       const edges = this.getPolygonEdges(face.polygon);       edges.forEach(edge => {         const key = this.getEdgeKey(edge);         if (edgeCount.get(key) === 1) {           boundaryEdges.push(edge);         }       });     });      return boundaryEdges;   }    private getEdgeKey(edge: [Point, Point]): string {     // Create consistent key regardless of edge direction     const [p1, p2] = edge;     const points = [p1, p2].sort((a, b) =>        a.getX() !== b.getX() ? a.getX() - b.getX() :       a.getY() !== b.getY() ? a.getY() - b.getY() :       a.getZ()! - b.getZ()!     );     return points.map(p =>        `${p.getX()},${p.getY()},${p.getZ()}`     ).join('-');   }    public override getCentroid(): Point {     if (this.faces.length === 0) {       throw new Error('Cannot compute centroid of empty surface');     }      let sumX = 0, sumY = 0, sumZ = 0;     let totalArea = 0;      this.faces.forEach(face => {       const centroid = face.polygon.getCentroid();       const area = face.polygon.getArea();       sumX += centroid.getX() * area;       sumY += centroid.getY() * area;       sumZ += centroid.getZ()! * area;       totalArea += area;     });      return new Point(       sumX / totalArea,       sumY / totalArea,       sumZ / totalArea     );   }    public override getPointAtParameters(u: number, v: number): Point | null {     // This is a simplified implementation that treats u,v as indices     // A more sophisticated implementation would need proper parameterization     if (u < 0 || u > 1 || v < 0 || v > 1) {       return null;     }      const faceIndex = Math.floor(u * this.faces.length);     const face = this.faces[faceIndex];     return face.polygon.getPointAtParameters(u * this.faces.length % 1, v);   }    public override getParametersAtPoint(point: Point): { u: number; v: number; } | null {     // Find which face contains the point     for (let i = 0; i < this.faces.length; i++) {       const face = this.faces[i];       if (face.polygon.contains(point)) {         const params = face.polygon.getParametersAtPoint(point);         if (params) {           return {             u: (i + params.u) / this.faces.length,             v: params.v           };         }       }     }     return null;   }    public override getBoundary(): Curve[] {     const boundaryEdges = this.getBoundaryEdges();     // Group edges into continuous curves     const curves: Point[][] = [];     let currentCurve: Point[] = [];      while (boundaryEdges.length > 0) {       if (currentCurve.length === 0) {         const [start, end] = boundaryEdges.pop()!;         currentCurve.push(start, end);       } else {         const lastPoint = currentCurve[currentCurve.length - 1];         const nextEdgeIndex = boundaryEdges.findIndex(([start]) =>            start.equals(lastPoint)         );          if (nextEdgeIndex !== -1) {           const [, end] = boundaryEdges.splice(nextEdgeIndex, 1)[0];           currentCurve.push(end);         } else {           curves.push(currentCurve);           currentCurve = [];         }       }     }      if (currentCurve.length > 0) {       curves.push(currentCurve);     }      // Convert point arrays to LinearRings     return curves.map(points => new LinearRing(points));   }    public override isClosed(): boolean {     return this.getBoundaryEdges().length === 0;   }    public override getNormalAtPoint(point: Point): Point | null {     // Find face containing point and return its normal     for (const face of this.faces) {       if (face.polygon.contains(point)) {         const points = face.polygon.getExteriorRing().getPoints();         return this.computeNormal(points[0], points[1], points[2]);       }     }     return null;   }    public override isPointOnSurface(point: Point, tolerance: number = 1e-10): boolean {     return this.faces.some(face => face.polygon.contains(point));   }    public override getClosestPoint(point: Point): Point {     let closestPoint = this.faces[0].polygon.getClosestPoint(point);     let minDistance = point.distanceTo(closestPoint);      for (let i = 1; i < this.faces.length; i++) {       const faceClosest = this.faces[i].polygon.getClosestPoint(point);       const distance = point.distanceTo(faceClosest);       if (distance < minDistance) {         closestPoint = faceClosest;         minDistance = distance;       }     }      return closestPoint;   }    // Geometry interface implementation   public override isEmpty(): boolean {     return this.faces.length === 0;   }    public override is3D(): boolean {     return true;   }    public override getGeometryType(): string {     return 'PolyhedralSurface Z';   }    public equals(other: Geometry): boolean {     if (!(other instanceof PolyhedralSurface)) {       return false;     }      if (this.faces.length !== other.faces.length) {       return false;     }      // Compare polygon patches (order-independent)     const unmatched = [...other.patches];     return this.patches.every(patch => {       const index = unmatched.findIndex(p => p.equals(patch));       if (index === -1) return false;       unmatched.splice(index, 1);       return true;     });   }    public override triangulate(maxTriangleSize: number = Infinity): Polygon[] {     const triangles: Polygon[] = [];          for (const face of this.faces) {       triangles.push(...face.polygon.triangulate(maxTriangleSize));     }      return triangles;   }    // Surface-specific methods   /**    * Gets all faces in the surface    */   public getFaces(): Polygon[] {     return this.patches.map(p => p.clone());   }    /**    * Gets all edges in the surface    * @param boundaryOnly If true, returns only boundary edges    */   public getEdges(boundaryOnly: boolean = false): [Point, Point][] {     if (boundaryOnly) {       return this.getBoundaryEdges();     }      const edges = new Set<string>();     const result: [Point, Point][] = [];      this.faces.forEach(face => {       const faceEdges = this.getPolygonEdges(face.polygon);       faceEdges.forEach(edge => {         const key = this.getEdgeKey(edge);         if (!edges.has(key)) {           edges.add(key);           result.push(edge);         }       });     });      return result;   }    /**    * Gets all vertices in the surface    */   public getVertices(): Point[] {     const vertices = new Set<string>();     const result: Point[] = [];      this.faces.forEach(face => {       face.polygon.getExteriorRing().getPoints().forEach(point => {         const key = `${point.getX()},${point.getY()},${point.getZ()}`;         if (!vertices.has(key)) {           vertices.add(key);           result.push(point.clone());         }       });     });      return result;   }    /**    * Gets the volume of the surface (if it forms a closed polyhedron)    */   public getVolume(): number | null {     if (!this.isClosed()) {       return null; // Cannot compute volume of non-closed surface     }      let volume = 0;     const origin = new Point(0, 0, 0);      // Use divergence theorem to compute volume     this.faces.forEach(face => {       const points = face.polygon.getExteriorRing().getPoints();       const normal = this.computeNormal(points[0], points[1], points[2]);              // Compute signed volume of tetrahedron formed by face and origin       for (let i = 0; i < points.length - 1; i++) {         const p1 = points[i];         const p2 = points[i + 1];         volume += this.signedTetrahedronVolume(origin, p1, p2, normal);       }     });      return Math.abs(volume);   }    private signedTetrahedronVolume(     origin: Point,     p1: Point,     p2: Point,     normal: Point   ): number {     const v1 = new Point(       p1.getX() - origin.getX(),       p1.getY() - origin.getY(),       p1.getZ()! - origin.getZ()!     );     const v2 = new Point(       p2.getX() - origin.getX(),       p2.getY() - origin.getY(),       p2.getZ()! - origin.getZ()!     );          // Triple scalar product     return (v1.getX() * v2.getY() * normal.getZ()! +             v2.getX() * normal.getY() * v1.getZ()! +             normal.getX() * v1.getY() * v2.getZ()! -             v1.getZ()! * v2.getY() * normal.getX() -             v2.getZ()! * normal.getY() * v1.getX() -             normal.getZ()! * v1.getY() * v2.getX()) / 6;   }    /**    * Gets the genus of the surface    */   public getGenus(): number {     const V = this.getVertices().length;     const E = this.getEdges().length;     const F = this.faces.length;          // Using Euler characteristic: V - E + F = 2 - 2g     // where g is the genus     return (2 - (V - E + F)) / 2;   }    /**    * Checks if the surface is orientable    */   public isOrientable(): boolean {     // A surface is orientable if we can assign consistent orientations     // to all faces such that adjacent faces have opposite orientations     // along their shared edges      if (this.faces.length === 0) return true;      const orientations = new Map<number, boolean>();     const visited = new Set<number>();     const stack: number[] = [0];     orientations.set(0, true);      while (stack.length > 0) {       const current = stack.pop()!;       visited.add(current);        const currentOrientation = orientations.get(current)!;       const face = this.faces[current];        // Visit neighbors       for (const neighbor of face.neighbors) {         if (!visited.has(neighbor)) {           orientations.set(neighbor, !currentOrientation);           stack.push(neighbor);         } else {           // Check if orientation is consistent           if (orientations.get(neighbor) === currentOrientation) {             return false;           }         }       }     }      return true;   }    /**    * Converts to Well-Known Text (WKT) format    */   public asWKT(): string {     if (this.isEmpty()) {       return 'POLYHEDRALSURFACE Z EMPTY';     }      const patchStrings = this.patches.map(patch => {       const points = patch.getExteriorRing().getPoints();       const coords = points.map(p =>          `${p.getX()} ${p.getY()} ${p.getZ()}`       ).join(', ');       return `((${coords}))`;     });      return `POLYHEDRALSURFACE Z (${patchStrings.join(', ')})`;   }    /**    * Creates from Well-Known Text (WKT)    */   public static fromWKT(wkt: string): PolyhedralSurface {     const match = wkt.match(/^POLYHEDRALSURFACE\s+Z\s*(\((.*)\))$/i);     if (!match) {       throw new Error('Invalid WKT format for PolyhedralSurface');     }      if (match[1].trim() === 'EMPTY') {       return new PolyhedralSurface([]);     }      // Parse polygon patches     const patches: Polygon[] = [];     const patchRegex = /\(\((.*?)\)\)/g;     let patchMatch;      while ((patchMatch = patchRegex.exec(match[2])) !== null) {       const coords = patchMatch[1].split(',').map(coord => {         const [x, y, z] = coord.trim().split(/\s+/).map(Number);         return new Point(x, y, z);       });       patches.push(new Polygon(new LinearRing(coords)));     }      return new PolyhedralSurface(patches);   }    /**    * Creates a deep copy of the surface    */   public clone(): PolyhedralSurface {     return new PolyhedralSurface(       this.patches,       this.srid,       this.coordinateSystem     );   }    /**    * Returns string representation    */   public toString(): string {     return this.asWKT();   } }  export { PolyhedralSurface };
|      |   +-- TIN.ts: import { Point, Geometry, CoordinateSystem } from '../base/Point'; import { LinearRing } from '../primitive/LinearRing'; import { Polygon } from '../primitive/Polygon'; import { Triangle } from './Triangle';   /**  * Implementation of a Triangulated Irregular Network (TIN)  * Represents a surface as a network of connected triangles  */ class TIN implements Geometry {   private triangles: Triangle[];   private points: Point[];   private srid: number;   private readonly coordinateSystem: CoordinateSystem;    /**    * Creates a new TIN    * @param points Array of points to triangulate    * @param srid Spatial Reference System Identifier    * @param coordinateSystem Coordinate system type    */   constructor(     points: Point[],     srid: number = 0,     coordinateSystem: CoordinateSystem = CoordinateSystem.CARTESIAN_2D   ) {     this.validatePoints(points);     this.points = points.map(p => p.clone());     this.srid = srid;     this.coordinateSystem = coordinateSystem;     this.triangles = this.createDelaunayTriangulation(this.points);   }     asWKT(): string {         throw new Error('Method not implemented.');     }    private validatePoints(points: Point[]): void {     if (points.length < 3) {       throw new Error('TIN requires at least 3 points');     }      // Check coordinate system consistency     const firstCs = points[0].getCoordinateSystem();     if (!points.every(p => p.getCoordinateSystem() === firstCs)) {       throw new Error('All points must have the same coordinate system');     }      // Check dimensionality consistency     const firstIs3D = points[0].is3D();     if (!points.every(p => p.is3D() === firstIs3D)) {       throw new Error('All points must be consistently 2D or 3D');     }   }    /**    * Creates a Delaunay triangulation from a set of points    * Uses the Bowyer-Watson incremental algorithm    */   private createDelaunayTriangulation(points: Point[]): Triangle[] {     // Create super-triangle that contains all points     const superTriangle = this.createSuperTriangle(points);     let triangulation = [superTriangle];      // Add points one at a time     for (const point of points) {       const badTriangles: Triangle[] = [];        // Find all triangles whose circumcircle contains the point       for (const triangle of triangulation) {         if (triangle.inCircumcircle(point)) {           badTriangles.push(triangle);         }       }        // Find boundary of polygon hole       const boundary: [Point, Point][] = [];       for (const triangle of badTriangles) {         const vertices = triangle.getVertices();         for (let i = 0; i < 3; i++) {           const edge: [Point, Point] = [vertices[i], vertices[(i + 1) % 3]];           let shared = false;                      for (const other of badTriangles) {             if (other === triangle) continue;             if (this.triangleContainsEdge(other, edge)) {               shared = true;               break;             }           }            if (!shared) {             boundary.push(edge);           }         }       }        // Remove bad triangles       triangulation = triangulation.filter(t => !badTriangles.includes(t));        // Re-triangulate the hole       for (const [p1, p2] of boundary) {         const newTriangle = new Triangle(point, p1, p2);         triangulation.push(newTriangle);       }     }      // Remove triangles that share vertex with super-triangle     const superVertices = superTriangle.getVertices();     triangulation = triangulation.filter(triangle => {       const vertices = triangle.getVertices();       return !vertices.some(v =>          superVertices.some(sv => v.equals(sv))       );     });      // Set up triangle neighbor relationships     this.establishNeighbors(triangulation);      return triangulation;   }    private createSuperTriangle(points: Point[]): Triangle {     // Find bounding box     let minX = Infinity, minY = Infinity;     let maxX = -Infinity, maxY = -Infinity;      for (const point of points) {       minX = Math.min(minX, point.getX());       minY = Math.min(minY, point.getY());       maxX = Math.max(maxX, point.getX());       maxY = Math.max(maxY, point.getY());     }      const dx = (maxX - minX) * 2;     const dy = (maxY - minY) * 2;     const centerX = (minX + maxX) / 2;     const centerY = (minY + maxY) / 2;      // Create triangle that encompasses all points with margin     return new Triangle(       new Point(centerX - dx, centerY - dy),       new Point(centerX + dx * 2, centerY - dy),       new Point(centerX, centerY + dy * 2)     );   }    private triangleContainsEdge(triangle: Triangle, edge: [Point, Point]): boolean {     const vertices = triangle.getVertices();     for (let i = 0; i < 3; i++) {       const v1 = vertices[i];       const v2 = vertices[(i + 1) % 3];       if ((edge[0].equals(v1) && edge[1].equals(v2)) ||           (edge[0].equals(v2) && edge[1].equals(v1))) {         return true;       }     }     return false;   }    private establishNeighbors(triangles: Triangle[]): void {     for (let i = 0; i < triangles.length; i++) {       const triangle = triangles[i];       const vertices = triangle.getVertices();        for (let j = i + 1; j < triangles.length; j++) {         const other = triangles[j];         const otherVertices = other.getVertices();          // Check each edge         for (let k = 0; k < 3; k++) {           const v1 = vertices[k];           const v2 = vertices[(k + 1) % 3];            for (let l = 0; l < 3; l++) {             const ov1 = otherVertices[l];             const ov2 = otherVertices[(l + 1) % 3];              if ((v1.equals(ov1) && v2.equals(ov2)) ||                 (v1.equals(ov2) && v2.equals(ov1))) {               triangle.setNeighbor(k, other);               other.setNeighbor(l, triangle);             }           }         }       }     }   }    // Geometry interface implementation   public isEmpty(): boolean {     return this.triangles.length === 0;   }    public is3D(): boolean {     return this.points.length > 0 && this.points[0].is3D();   }    public dimension(): number {     return 2; // TINs are 2-dimensional surfaces   }    public getSRID(): number {     return this.srid;   }    public setSRID(srid: number): void {     if (srid < 0) {       throw new Error('SRID must be non-negative');     }     this.srid = srid;   }    public getGeometryType(): string {     return 'TIN';   }    public equals(other: Geometry): boolean {     if (!(other instanceof TIN)) {       return false;     }      const otherTin = other as TIN;     if (this.points.length !== otherTin.points.length) {       return false;     }      // Compare points (order-independent)     const thisPoints = new Set(this.points.map(p => p.toString()));     return otherTin.points.every(p => thisPoints.has(p.toString()));   }    // Additional TIN-specific methods   /**    * Gets all triangles in the TIN    */   public getTriangles(): Triangle[] {     return [...this.triangles];   }    /**    * Gets all points in the TIN    */   public getPoints(): Point[] {     return this.points.map(p => p.clone());   }    /**    * Gets the triangle containing a point    * @returns The containing triangle or null if not found    */   public getTriangleAt(point: Point): Triangle | null {     for (const triangle of this.triangles) {       if (triangle.contains(point)) {         return triangle;       }     }     return null;   }    /**    * Interpolates a Z value at a given point    * Uses linear interpolation within the containing triangle    */   public interpolateZ(point: Point): number | null {     const triangle = this.getTriangleAt(point);     if (!triangle || !this.is3D()) {       return null;     }      const [v1, v2, v3] = triangle.getVertices();     const area = triangle.getArea();      // Barycentric coordinates     const area1 = new Triangle(point, v2, v3).getArea();     const area2 = new Triangle(v1, point, v3).getArea();     const area3 = new Triangle(v1, v2, point).getArea();      const w1 = area1 / area;     const w2 = area2 / area;     const w3 = area3 / area;      // Interpolate Z value using barycentric coordinates     return w1 * v1.getZ()! + w2 * v2.getZ()! + w3 * v3.getZ()!;   }    /**    * Gets the surface area of the TIN    */   public getSurfaceArea(): number {     return this.triangles.reduce((sum, triangle) => sum + triangle.getArea(), 0);   }    /**    * Gets the boundary of the TIN as a collection of edges    * @returns Array of edge segments that form the boundary    */   public getBoundary(): [Point, Point][] {     const edges = new Map<string, number>();      // Count occurrences of each edge     for (const triangle of this.triangles) {       const vertices = triangle.getVertices();       for (let i = 0; i < 3; i++) {         const v1 = vertices[i];         const v2 = vertices[(i + 1) % 3];         const edgeKey = this.getEdgeKey(v1, v2);         edges.set(edgeKey, (edges.get(edgeKey) || 0) + 1);       }     }      // Collect edges that appear only once (boundary edges)     const boundary: [Point, Point][] = [];     for (const triangle of this.triangles) {       const vertices = triangle.getVertices();       for (let i = 0; i < 3; i++) {         const v1 = vertices[i];         const v2 = vertices[(i + 1) % 3];         const edgeKey = this.getEdgeKey(v1, v2);         if (edges.get(edgeKey) === 1) {           boundary.push([v1.clone(), v2.clone()]);         }       }     }      return boundary;   }    /**    * Creates a unique key for an edge    */   private getEdgeKey(p1: Point, p2: Point): string {     // Order points consistently to ensure same key for same edge     const [minP, maxP] = p1.getX() < p2.getX() ? [p1, p2] : [p2, p1];     return `${minP.getX()},${minP.getY()}-${maxP.getX()},${maxP.getY()}`;   }    /**    * Finds the steepest slope at a given point    * @returns Slope in degrees or null if point is not in TIN or TIN is not 3D    */   public getSteepestSlope(point: Point): number | null {     if (!this.is3D()) {       return null;     }      const triangle = this.getTriangleAt(point);     if (!triangle) {       return null;     }      const [v1, v2, v3] = triangle.getVertices();          // Calculate normal vector using cross product     const ux = v2.getX() - v1.getX();     const uy = v2.getY() - v1.getY();     const uz = v2.getZ()! - v1.getZ()!;          const vx = v3.getX() - v1.getX();     const vy = v3.getY() - v1.getY();     const vz = v3.getZ()! - v1.getZ()!;          const nx = uy * vz - uz * vy;     const ny = uz * vx - ux * vz;     const nz = ux * vy - uy * vx;          // Calculate slope angle     const length = Math.sqrt(nx * nx + ny * ny + nz * nz);     const cosAngle = Math.abs(nz) / length;     return Math.acos(cosAngle) * 180 / Math.PI;   }    /**    * Converts the TIN to a collection of polygons    * Each triangle becomes a polygon    */   public toPolygons(): Polygon[] {     return this.triangles.map(triangle => {       const vertices = triangle.getVertices();       const ring = new LinearRing([         ...vertices,         vertices[0].clone() // Close the ring       ]);       return new Polygon(ring);     });   }    /**    * Finds all points within a given radius of a point    */   public findPointsWithinRadius(center: Point, radius: number): Point[] {     return this.points.filter(p => p.distanceTo(center) <= radius)                      .map(p => p.clone());   }    /**    * Validates the TIN structure    * Checks for topological correctness    * @returns Array of validation errors, empty if valid    */   public validate(): string[] {     const errors: string[] = [];      // Check for minimum points     if (this.points.length < 3) {       errors.push('TIN must have at least 3 points');     }      // Check for duplicate points     const pointMap = new Map<string, number>();     this.points.forEach((point, index) => {       const key = `${point.getX()},${point.getY()}`;       if (pointMap.has(key)) {         errors.push(`Duplicate point found at indices ${pointMap.get(key)} and ${index}`);       }       pointMap.set(key, index);     });      // Check triangle connectivity     for (const triangle of this.triangles) {       const neighbors = triangle.getNeighbors();       for (let i = 0; i < 3; i++) {         const neighbor = neighbors[i];         if (neighbor) {           // Check reciprocal relationship           const neighborVertices = neighbor.getVertices();           const triangleVertices = triangle.getVertices();           let found = false;           for (let j = 0; j < 3; j++) {             if (neighbor.getNeighbors()[j] === triangle) {               found = true;               break;             }           }           if (!found) {             errors.push('Inconsistent triangle neighbor relationship found');           }         }       }     }      // Check for overlapping triangles     for (let i = 0; i < this.triangles.length; i++) {       const tri1 = this.triangles[i];       for (let j = i + 1; j < this.triangles.length; j++) {         const tri2 = this.triangles[j];         if (this.trianglesOverlap(tri1, tri2)) {           errors.push(`Overlapping triangles found at indices ${i} and ${j}`);         }       }     }      return errors;   }    private trianglesOverlap(tri1: Triangle, tri2: Triangle): boolean {     // Check if any vertex of one triangle is inside the other     const vertices1 = tri1.getVertices();     const vertices2 = tri2.getVertices();      for (const vertex of vertices1) {       if (tri2.contains(vertex)) {         return true;       }     }      for (const vertex of vertices2) {       if (tri1.contains(vertex)) {         return true;       }     }      return false;   }    /**    * Simplifies the TIN by removing points that contribute least to the surface accuracy    * @param maxError Maximum allowed vertical error    * @returns A new simplified TIN    */   public simplify(maxError: number): TIN {     if (!this.is3D()) {       throw new Error('Simplification requires 3D points');     }      // Calculate importance of each point     const importance = new Map<Point, number>();     for (const point of this.points) {       importance.set(point, this.calculatePointImportance(point));     }      // Sort points by importance     const sortedPoints = [...this.points].sort((a, b) =>        (importance.get(b) || 0) - (importance.get(a) || 0)     );      // Keep removing points until error threshold is exceeded     const keepPoints = new Set<Point>();     for (const point of sortedPoints) {       const testPoints = new Set(keepPoints);       testPoints.add(point);              if (this.calculateMaxError(testPoints) <= maxError) {         keepPoints.add(point);       }     }      return new TIN(Array.from(keepPoints), this.srid, this.coordinateSystem);   }    private calculatePointImportance(point: Point): number {     // Calculate how much this point contributes to the surface variation     const neighbors = this.findNeighborPoints(point);     if (neighbors.length === 0) return 0;      let sumDiff = 0;     for (const neighbor of neighbors) {       sumDiff += Math.abs(point.getZ()! - neighbor.getZ()!);     }     return sumDiff / neighbors.length;   }    private findNeighborPoints(point: Point): Point[] {     const neighbors: Point[] = [];     for (const triangle of this.triangles) {       const vertices = triangle.getVertices();       const index = vertices.findIndex(v => v.equals(point));       if (index !== -1) {         neighbors.push(vertices[(index + 1) % 3]);         neighbors.push(vertices[(index + 2) % 3]);       }     }     return [...new Set(neighbors)];   }    private calculateMaxError(points: Set<Point>): number {     const testTin = new TIN(Array.from(points), this.srid, this.coordinateSystem);     let maxError = 0;      for (const point of this.points) {       if (!points.has(point)) {         const interpolated = testTin.interpolateZ(point);         if (interpolated !== null) {           const error = Math.abs(point.getZ()! - interpolated);           maxError = Math.max(maxError, error);         }       }     }      return maxError;   } }  export { TIN };
|      |   -- Triangle.ts: import { Point } from "../base/Point";  /**  * Represents a triangle in a TIN  */ class Triangle {     private vertices: [Point, Point, Point];     private neighbors: [Triangle | null, Triangle | null, Triangle | null];        constructor(v1: Point, v2: Point, v3: Point) {       // Ensure vertices are ordered counterclockwise       if (this.isClockwise(v1, v2, v3)) {         this.vertices = [v1, v2, v3];       } else {         this.vertices = [v1, v3, v2];       }       this.neighbors = [null, null, null];     }        /**      * Gets the vertices of the triangle      */     getVertices(): [Point, Point, Point] {       return [         this.vertices[0].clone(),         this.vertices[1].clone(),         this.vertices[2].clone()       ];     }        /**      * Gets the neighboring triangles      */     getNeighbors(): [Triangle | null, Triangle | null, Triangle | null] {       return [...this.neighbors];     }        /**      * Sets a neighboring triangle      * @param index Edge index (0-2)      * @param neighbor The neighboring triangle      */     setNeighbor(index: number, neighbor: Triangle | null): void {       if (index < 0 || index > 2) {         throw new Error('Invalid neighbor index');       }       this.neighbors[index] = neighbor;     }        /**      * Calculates the circumcenter of the triangle      */     getCircumcenter(): Point {       const [a, b, c] = this.vertices;              const D = 2 * (a.getX() * (b.getY() - c.getY()) +                      b.getX() * (c.getY() - a.getY()) +                      c.getX() * (a.getY() - b.getY()));          const Ux = ((a.getX() * a.getX() + a.getY() * a.getY()) * (b.getY() - c.getY()) +                   (b.getX() * b.getX() + b.getY() * b.getY()) * (c.getY() - a.getY()) +                   (c.getX() * c.getX() + c.getY() * c.getY()) * (a.getY() - b.getY())) / D;          const Uy = ((a.getX() * a.getX() + a.getY() * a.getY()) * (c.getX() - b.getX()) +                   (b.getX() * b.getX() + b.getY() * b.getY()) * (a.getX() - c.getX()) +                   (c.getX() * c.getX() + c.getY() * c.getY()) * (b.getX() - a.getX())) / D;          return new Point(Ux, Uy);     }        /**      * Tests if a point lies within the triangle's circumcircle      */     inCircumcircle(point: Point): boolean {       const center = this.getCircumcenter();       const radius = center.distanceTo(this.vertices[0]);       return point.distanceTo(center) < radius;     }        /**      * Calculates the area of the triangle      */     getArea(): number {       const [a, b, c] = this.vertices;       return Math.abs(         (b.getX() - a.getX()) * (c.getY() - a.getY()) -         (c.getX() - a.getX()) * (b.getY() - a.getY())       ) / 2;     }        /**      * Tests if a point lies within the triangle      */     contains(point: Point): boolean {       const [a, b, c] = this.vertices;              const v0x = c.getX() - a.getX();       const v0y = c.getY() - a.getY();       const v1x = b.getX() - a.getX();       const v1y = b.getY() - a.getY();       const v2x = point.getX() - a.getX();       const v2y = point.getY() - a.getY();          const dot00 = v0x * v0x + v0y * v0y;       const dot01 = v0x * v1x + v0y * v1y;       const dot02 = v0x * v2x + v0y * v2y;       const dot11 = v1x * v1x + v1y * v1y;       const dot12 = v1x * v2x + v1y * v2y;          const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);       const u = (dot11 * dot02 - dot01 * dot12) * invDenom;       const v = (dot00 * dot12 - dot01 * dot02) * invDenom;          return u >= 0 && v >= 0 && u + v <= 1;     }        private isClockwise(p1: Point, p2: Point, p3: Point): boolean {       return ((p2.getX() - p1.getX()) * (p3.getY() - p1.getY()) -               (p3.getX() - p1.getX()) * (p2.getY() - p1.getY())) > 0;     }   }      export { Triangle };
|      -- util
|         +-- GeometryValidator.ts: 
|         +-- MathUtil.ts: 
|         -- WKTParser.ts: 
+-- test
|   -- geometry
|      +-- base
|      |   +-- Coordinates.test.ts: 
|      |   +-- Geometry.test.ts: 
|      |   -- Point.test.ts: 
|      +-- collection
|      |   +-- GeometryCollection.test.ts: 
|      |   +-- MultiLineString.test.ts: 
|      |   +-- MultiPoint.test.ts: 
|      |   -- MultiPolygon.test.ts: 
|      +-- operation
|      |   +-- binary
|      |   |   -- BinaryOperations.test.ts: 
|      |   +-- predicate
|      |   |   -- GeometricPredicates.test.ts: 
|      |   -- unary
|      |      -- UnaryOperations.test.ts: 
|      +-- primitive
|      |   +-- Curve.test.ts: 
|      |   +-- LineString.test.ts: 
|      |   +-- Polygon.test.ts: 
|      |   -- Surface.test.ts: 
|      +-- surface
|      |   +-- PolyhedralSurface.test.ts: 
|      |   -- TIN.test.ts: 
|      -- util
|         +-- GeometryValidator.test.ts: 
|         +-- MathUtil.test.ts: 
|         -- WKTParser.test.ts: 
+-- tree-content.py
+-- tsconfig.json
-- vitest-config.ts: // vitest.config.ts import { defineConfig } from 'vitest/config'  export default defineConfig({   test: {     globals: true,     coverage: {       provider: 'v8',       reporter: ['text', 'json', 'html'],     },   }, })
